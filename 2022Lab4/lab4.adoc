:figure-caption: Рисунок
:table-caption: Таблица
= Анализ требований к разработке
:toc:
:toc-title: Оглавление:

Тема работы: *Разработка метеостанции с передачей параметров по беспроводному интерфейсу*

Чепульская О.С., Яковенко А.Д. КЭ-413 +


= Для разработки должна использоваться отладочная плата XNUCLEO-F411RE

XNUCLEO-F411RE – это отладочная плата от компании Waveshare с поддержкой Arduino, которая позволит изучить возможности микроконтроллера STM32F411RET6 на базе ядра Cortex-M3.

.Вид платы XNUCLEO-F411RE.
image::kr1.png[300, 300]


= Питание платы должно быть автономным и подаваться с солнечный батарей

Питание будет подаваться с модуля управления солнечной энергией, для панели солнечных батарей 6V~24V. 
Этот модуль управления солнечной энергией может заряжать аккумуляторную литиевую батарею 3.7 V через солнечную панель или USB-соединение и обеспечивает регулируемый выход 5V/1A.

Характеристики:

* Напряжение солнечной панели (SOLAR IN): 6V ~ 24V;
* Зарядные устройства: Солнечная панель, адаптер питания, USB;
* USB-интерфейс зарядки: Micro USB: 5V/1A;
* Внутренняя литий-батарея: 3.7 V 14500 Li-battery;
* Входное напряжение USB: 5V (интерфейс Micro USB);
* Выход 5V: 5V / 1A (USB OUT, GPIO);
* Защита от напряжения отключения заряда: 4.2 V ± 1％;
* Напряжение защиты от перегрузки: 2.9V ± 1％;
* Эффективность заряда солнечной панели: 78%;
* Эффективность зарядки USB: 82%;
* Максимальный ток покоя: <2мА;
* Рабочая температура: -40℃ ~ 85℃.

.Модуль управления солнечной энергией
image::kr2.png[250, 250]

.Способ подключения солнечной батареи
image::kr3.png[500, 500]

= Программное обеспечение измерение должно измерять давление, влажность и температуру и рассчитывать точку росы.


*Период измерения должен быть 100 ms.*


=== Для измерения давления, влажности и температуры должен использоваться датчик BME280

BME280 – высокоточный метеодатчик, измеряющий такие параметры микроклимата как температура, влажность и атмосферное давление. +
В зависимости от модуля может подключаться к I2C и SPI шинами микроконтроллера и работать от 3-5V, если на плате есть стабилизатор, или 3V, если его нет. +
Данный модуль работает по двухпроводному интерфейсу I2C, адрес по умолчанию 0x76, но есть возможность изменить на адрес 0x77. Модуль подключается на шину I2C и питание, как и любой другой модуль такого типа. +

Примеры библиотек для работы с датчиком:

* Adafruit BME280 (для работы также нужна Adafruit Sensor) – самая известная библиотека для работы с BME280. Часть настроек доступна только при ручном редактировании библиотеки.
* GyverBME280 –Также поддерживает датчики BMP280

Благодаря сверхмалому форм-фактору, низкому энергопотреблению, высокой точности и стабильности датчик окружающей среды BME280 подходит для таких применений, как мониторинг окружающей среды, прогноз погоды.

*Управление питанием*. BME280 имеет два отдельных вывода источника питания:

* Vdd является основным источником питания для всех внутренних аналоговых и цифровых функциональных блоков;
* Vddio - это отдельный вывод источника питания, используемый для питания цифрового интерфейса.

Встроенный генератор сброса питания (POR), он сбрасывает логическую часть и значения регистра после обоих Vdd и Vddio достигают своих минимальных уровней. Нет никаких ограничений на наклон и последовательность повышения уровней Vdd и Vddio.

*Режимы датчика*. BME280 предлагает три режима работы датчика: 

* Sleep mode: не работает, доступны все регистры, самая низкая мощность, выбирается после запуска;
* Forced mode: выполнит одно измерение, сохранит результаты и вернется в спящий режим;
* Normal mode: непрерывный цикл измерений и периоды бездействия.



=== Общение с датчиком должно осуществляться по интерфейсу SPIx (где х - любой не равный 1,2,3)

Последовательный периферийный интерфейс (SPI) обеспечивает полудуплексную/полнодуплексную синхронную последовательную связь с внешними устройствами. Интерфейс может быть сконфигурирован как ведущий, и в этом случае он обеспечивает синхронизацию связи (SCK) с внешним подчиненным устройством. + 
Интерфейс также способен работать в конфигурации multimaster. Он может использоваться для различных целей, включая симплексную синхронную передачу по двум линиям с возможной двунаправленной линией передачи данных или надежную связь с использованием проверки CRC. +
Интерфейс SPI имеет два режима: 4-проводной и 3-проводной. Протокол одинаков для обоих.




Интерфейс SPI:

|===
|Function pin | STM32 interface | Describe

| VCC		
| 3.3V /5V
| Входная мощность 3.3V

| GND		
| GND
| Земля

| MOSI
| PA7		
| SPI data input

| SCK
| PA5		
| SPI clock input


| MISO
| PA6		
| SPI data output

| CS	
| PB6
| Выбор чипа SPI, активный при низком напряжении

|===



Обычно SPI подключается к внешним устройствам через четыре контакта:

* MISO: Master In / Slave Out data. 
* MOSI: Master Out / Slave In data. 
* SCK: Serial Clock output for SPI masters and input for SPI slaves. (Последовательный тактовый выход для ведущих SPI и вход для ведомых SPI.)
* NSS: Slave select. This is an optional pin to select a slave device. (Выбор ведомого устройства, позволяя ведущему SPI взаимодействовать с подчиненными устройствами индивидуально и избегать конфликтов в линиях передачи данных.)


image::kr12.png[600, 600]

.Структурная схема SPI
image::kr11.png[]


Контакты MOSI и контакты MISO соединены вместе. Таким образом, данные передаются последовательно между ведущим и ведомым (сначала самый значимый бит).

Общение всегда инициируется мастером. Когда ведущее устройство передает данные на подчиненное устройство через вывод MOSI, подчиненное устройство отвечает через вывод MISO. Это подразумевает полнодуплексную связь как с выводом данных, так и с вводом данных, синхронизированных с одним и тем же тактовым сигналом (который обеспечивается главным устройством через вывод SCK).

*Управление выводами Slave select (NSS)*

Управление выбором аппаратного или программного подчиненного устройства можно настроить с помощью бита SSM в регистре SPI_CR1.

* Программное обеспечение для управления NSS (SSM = 1)

Информация о выборе ведомого устройства управляется внутренне значением бита SSI в регистре SPI_CR1. Внешний контакт NSS остается свободным для использования в других приложениях.

* Аппаратное управление NSS (SSM = 0)

Возможны две конфигурации в зависимости от конфигурации вывода NSS (бит SSOE в регистре SPI_CR2). +
– Выход NSS включен (SSM = 0, SSOE = 1) +
Эта конфигурация используется только тогда, когда устройство работает в главном режиме. Сигнал NSS становится низким, когда ведущий начинает связь, и остается низким до тех пор, пока SPI не будет отключен. +
– Выход NSS отключен (SSM = 0, SSOE = 0) +
Для устройств, настроенных как подчиненные, вывод NSS действует как классический вход NSS: подчиненный выбирается, когда NSS низкий, и отменяется, когда NSS высокий.


*Настройка SPI в подчиненном режиме*

В конфигурации ведомого устройства последовательные тактовые сигналы поступают на вывод SCK от ведущего устройства. Значение, установленное в битах BR[2:0] в регистре SPI_CR1, не влияет на скорость передачи данных.

Процедура: +
1) Установите бит DFF для определения 8- или 16-разрядного формата фрейма данных +

image::kr13.png[]

2) Выберите биты CPOL и CPHA, чтобы определить одно из четырех соотношений между передачей данных и последовательным тактовым сигналом. Для правильной передачи данных биты CPOL и CPHA должны быть настроены одинаково на подчиненном устройстве и главном устройстве. +

image::kr14.png[]

3) Формат кадра (MSB-first или LSB-first в зависимости от значения бита LSBFIRST в регистре SPI_CR1) должен совпадать с форматом главного устройства. +

image::kr15.png[]

4) В аппаратном режиме вывод NSS должен быть подключается к сигналу низкого уровня во время полной последовательности передачи байтов. В программном режиме NSS установите бит SSM и очистите бит SSI в регистре SPI_CR1. +

image::kr16.png[]

5) Установите бит RF в регистре SPI_CR2, чтобы выбрать протокол режима TI для последовательной связи (можно использовать для настройки последовательной связи). +

image::kr17.png[]


6) Очистите бит MSTR и установите бит SPE (оба в регистре SPI_CR1), чтобы назначить контакты альтернативным функциям. +
В этой конфигурации вывод MOSI является вводом данных, а вывод MISO - выводом данных.

image::kr18.png[400, 400]


*Настройка SPI в главном режиме*

В основной конфигурации последовательный тактовый сигнал генерируется на выводе SCK.

Процедура: +
1) Установите бит DFF для определения 8- или 16-разрядного формата фрейма данных +

image::kr13.png[]

2) Выберите биты CPOL и CPHA, чтобы определить одно из четырех соотношений между передачей данных и последовательным тактовым сигналом. Для правильной передачи данных биты CPOL и CPHA должны быть настроены одинаково на подчиненном устройстве и главном устройстве. +


image::kr14.png[]

3) Формат кадра (MSB-first или LSB-first в зависимости от значения бита LSBFIRST в регистре SPI_CR1) должен совпадать с форматом главного устройства. +

image::kr15.png[]


4) В аппаратном режиме вывод NSS должен быть подключен к сигналу низкого уровня во время полной последовательности передачи байтов. В программном режиме NSS установите бит SSM и очистите бит SSI в регистре SPI_CR1. +

image::kr16.png[]

5) Установите бит RF в регистре SPI_CR2, чтобы выбрать протокол режима TI для последовательной связи. +

image::kr17.png[]

6) Очистите бит MSTR и установите бит SPE (оба в регистре SPI_CR1), чтобы назначить контакты альтернативным функциям. +
В этой конфигурации вывод MOSI является вводом данных, а вывод MISO - выводом данных.


image::kr18.png[400, 400]


*Настройка SPI для полудуплексной связи SPI способен работать в полудуплексном режиме в 2 конфигурациях.*

* 1 тактовый и 1 двунаправленный провод передачи данных
* 1 тактовая частота и 1 провод передачи данных (только для приема или только для передачи)

1 тактовая частота и 1 двунаправленный провод передачи данных (BIDIMODE = 1)
Этот режим включается путем установки бита BIDIMODE в регистре SPI_CR1. 

image::kr19.png[ ]

В этом режиме SCK используется для синхронизации, а MOSI в главном или MISO в подчиненном режиме используется для передачи данных связь. Направление передачи (ввод/вывод) выбирается битом BIDIOE в регистре SPI_CR1. Когда этот бит равен 1, строка данных выводится, в противном случае она вводится.


image::kr20.png[]

1 тактовая частота и 1 однонаправленный провод передачи данных (BIDIMODE = 0)
В этом режиме приложение может использовать SPI либо в режиме только передачи, либо в режиме только приема.

* Режим только передачи аналогичен полнодуплексному режиму (BIDIMODE= 0, RXONLY =0): данные передаются на вывод передачи (MOSI в главном режиме или MISO в подчиненном режиме), а вывод приема (MISO в главном режиме или MOSI в подчиненном режиме) может использоваться в качестве ввод-вывод общего назначения. 


image::kr21.png[]

* В режиме только для приема приложение может отключить функцию вывода SPI, установив бит RXONLY в регистре SPI_CR1. В этом случае он освобождает вывод ввода-вывода передачи (MOSI в режим master или MISO в режиме slave), поэтому его можно использовать для других целей.




*Отключение SPI*

Когда передача завершается, приложение может остановить связь, отключив периферийное устройство SPI. Это делается путем очистки бита SPE. +
Для некоторых конфигураций отключение SPI и переход в режим остановки во время выполнения передачи могут привести к повреждению текущей передачи и/или флаг BSY может стать ненадежным. +
Чтобы избежать любого из этих эффектов, рекомендуется соблюдать следующую процедуру при отключении SPI: +
В ведущем или ведомом полнодуплексном режиме (BIDIMODE=0, RXONLY=0) +
1. Подождите, пока RXNE=1, чтобы получить последние данные +
2. Подождите, пока TXE=1 +
3. Затем подождите, пока BSY=0 +
4. Отключите SPI (SPE=0) и, в конечном итоге, войдите в режим остановки (или отключите периферийные часы). +
В ведущем или ведомом режиме только однонаправленной передачи (BIDIMODE=0, RXONLY=0) или в режиме двунаправленной передачи (BIDIMODE=1, BIDIOE=1) После записи последних данных в регистр SPI_DR: +
1. Подождите, пока TXE=1 +
2. Затем подождите, пока BSY=0 +
3. Отключите SPI (SPE=0) и, в конечном итоге, войдите в режим остановки (или отключите периферийные часы).



Для примера приведём часть инициализации использования SPI для датчика BME280, с использованием библиотеки предоставленной Bosch Sensortec:

[source, cpp]
struct bme280_dev dev;
int8_t rslt = BME280_OK;
/* Sensor_0 interface over SPI with native chip select line */
dev.dev_id = 0;
dev.intf = BME280_SPI_INTF;
dev.read = user_spi_read;
dev.write = user_spi_write;
dev.delay_ms = user_delay_ms;
rslt = bme280_init(&dev);


Среди них bme280_dev - это структура устройства BME280, приведенная в официальной библиотеке. Он используется для инициализации и сбора данных. Реализует следующие функции:

[source, cpp]
user_spi_read()
user_spi_write()
user_delay_ms()


Функция считывания данных BME280:

[source, cpp]
int8_t stream_sensor_data_forced_mode(struct bme280_dev *dev)
int8_t stream_sensor_data_normal_mode(struct bme280_dev *dev)


все вышеперечисленные функции вызывают функцию вывода:

[source, cpp]
void print_sensor_data(struct bme280_data *comp_data)


Идеи реализации функций, чтения SPI, записи SPI заключаются в следующем:


[source, cpp]
void user_delay_ms(uint32_t period)
{
    /*
     * Return control or wait,
     * for a period amount of milliseconds
     */
}
int8_t user_spi_read(uint8_t dev_id, uint8_t reg_addr, uint8_t *reg_data, uint16_t len)
{
    int8_t rslt = 0; /* Return 0 for Success, non-zero for failure */
    /*
     * The parameter dev_id can be used as a variable to select which Chip Select pin has
     * to be set low to activate the relevant device on the SPI bus
     */
    /*
     * Data on the bus should be like
     * |----------------+---------------------+-------------|
     * | MOSI           | MISO                | Chip Select |
     * |----------------+---------------------|-------------|
     * | (don't care)   | (don't care)        | HIGH        |
     * | (reg_addr)     | (don't care)        | LOW         |
     * | (don't care)   | (reg_data[0])       | LOW         |
     * | (....)         | (....)              | LOW         |
     * | (don't care)   | (reg_data[len - 1]) | LOW         |
     * | (don't care)   | (don't care)        | HIGH        |
     * |----------------+---------------------|-------------|
     */
    return rslt;
}
int8_t user_spi_write(uint8_t dev_id, uint8_t reg_addr, uint8_t *reg_data, uint16_t len)
{
    int8_t rslt = 0; /* Return 0 for Success, non-zero for failure */
    /*
     * The parameter dev_id can be used as a variable to select which Chip Select pin has
     * to be set low to activate the relevant device on the SPI bus
     */
    /*
     * Data on the bus should be like
     * |---------------------+--------------+-------------|
     * | MOSI                | MISO         | Chip Select |
     * |---------------------+--------------|-------------|
     * | (don't care)        | (don't care) | HIGH        |
     * | (reg_addr)          | (don't care) | LOW         |
     * | (reg_data[0])       | (don't care) | LOW         |
     * | (....)              | (....)       | LOW         |
     * | (reg_data[len - 1]) | (don't care) | LOW         |
     * | (don't care)        | (don't care) | HIGH        |
     * |---------------------+--------------|-------------|
     */
    return rslt;
}

Подводя итог, на основе официальной библиотеки, основной процесс получения данных BME280 для различных платформ выглядит следующим образом: + 
*Шаг 1:* Инициализация системы и периферийных устройств. +
*Шаг 2:* Реализуйте функции чтения SPI, записи SPI, задержки на разных платформах, назначьте указатель функции переменной-члену структуры bme280_dev и передайте указатель структуры для инициализации и после этого можно инициализировать устройство BME280. +
*Шаг 3:* Вызов функции int8_t stream_sensor_data_forced_mode(struct bme280_dev *dev) или функции int8_t stream_sensor_data_normal_mode(struct bme280_dev *dev), получая данные датчика BME280 и выводит их на главный компьютер или консоль. +



=== Точка росы должна считаться на основе текущих показаний влажности и давления

В данном курсовом проекте необходимо рассчитать и вывести точку росы.

Температура точки росы газа (точка росы) — значение температуры газа, при которой водяной пар, содержащийся в газе, охлаждаемом изобарически, становится насыщенным над плоской поверхностью воды.

Точка росы – это температура воздуха, при которой содержащийся в нём пар достигает состояния насыщения и начинает конденсироваться в росу.

*Точка росы бывает двух видов*: точка росы под давлением и атмосферная точка росы.

*1. Точка росы под давлением [°Cтрд]*

Точка росы под давлением [°Cтрд] - это температура, до которой сжатый воздух может быть охлажден без образования конденсата. Точка росы зависит от давления процесса. Когда давление падает, точка росы также снижается.

Говоря о системах под давлением, мы имеем в виду точку росы под давлением, но не атмосферную точку росы. Описание различий между этими двумя физическими параметрами приводится ниже.

*2. Атмосферная точка росы [°CtdA]*

Атмосферная точка росы [°CтрА] – температура, до которой атмосферный воздух (воздух под давлением приблиз. 1 бар абс.) может быть охлажден без образования конденсата.
В требованиях не сказано какая точка росы необходима.

При анализе точки росы под давлением было выяснено, что данная точка расчитывается путем диаграмм Молье. +
Традиционные психрометрические диаграммы верны только при одном уровне давления, обычно при атмосферном давлении (применение в области технологий кондиционирования воздуха, см. “Стационарные технологии для измерения влажности, дифференциального давления и температуры”). +
Психрометрическая диаграмма ниже показывает соотношение разных переменных влажности (точка росы [°Cтр],относительная влажность [%ОВ] и степень влажности [г/кг] также, как и температура [°C] ) в том числе при неатмосферном давлении. +

.Диаграмма Молье
image::kr5.png[500, 500]


Так как данное преобразование занимает больше времени, чем отводится на реализацию проекта, было установлено, что расчет будет проводится только атмосферной точки росы. +
Формула для приблизительного расчёта точки росы в градусах Цельсия (только для положительных температур):

image::kr6.png[]

где: +
a = 17,27, +
b= 237,7 °C, +

image::kr8.png[170, 170]

Т - температура в градусах Цельсия, +
RH - относительная влажность в объёмных долях (0 < RH < 1,0). +

Формула обладает погрешностью ±0,4 °C в следующем диапазоне значений:

0 °C <T < 60 °C +
0,01 < RH < 1,00 +
0 °C < T, < 50 °C +


Существует более простая формула для приблизительного расчёта, дающая погрешность ±1,0 °C при относительной влажности в объёмных долях более 0,5. +
Эту формулу можно использовать для вычисления относительной влажности по известной точке росы. +
При анализе выяснено, что расчет идет а.т.р. так как диаграммы молье сложны для реализации в короткие сроки, потому что необходима интерполяция и аппроксимация функций, а также из-за отсутствия условий на диапазон используемого давления, мы не можем определить нужные нам функции для работы с точкой росы под давлением. +
 

= Передача значений по беспроводному интерфейсу должна осуществляться через модуль BlueTooth Bee HC-06

Беспроводной модуль для приема/передачи данных в Arduino проектах по протоколу Bluetooth.

Особенности:

* Поддерживает работу с любым USB Bluetooth адаптером;
* Скорость передачи данных: 9600 бит/сек;
* Встроенная антенна;
* Радиус действия до 10 метров.
* Питание 3,3В – 6 В;
* Скорость передачи данных 1200–1382400 бод;
* Рабочие частоты 2,40 ГГц – 2,48ГГц;


Модуль HC-06 используется только в режиме slave, то есть он не может самостоятельно подключаться к другим устройствам Bluetooth. Все настройки для подключения «пароль, скорость передачи данных» можно изменить при помощи АТ-команд.


Основная функция модуля Bluetooth - это организация связи по последовательному интерфейсу там, где ранее для связи применялась кабельная линия.

Основные заводские параметры HC-06:

* *Режим ведущего:* имеет встроенную память, для запоминания последнего связанного ведомого устройства. Устанавливает связь только если на контакт (PIN26) подан низкий уровень. По умолчанию на PIN26 установлен низкий уровень.
* *Установка связи:* ведущее устройство осуществляет поиск и соединение с ведомым автоматически.
* *Основной метод:* при выполнении некоторых условий, ведущее и ведомые устройства соединяются автоматически.
* *AT режим:* До установления связи устройство работает в режиме AT. После установления связи с другим устройством идёт прямая передача информации.
* Во время установления связи модуль не может входить в режим AT.
* *Скорость* по умолчанию — 9600.
* Светодиод LED: Период мигания ведомого устройства — 102мс. Если ведущее устройство уже есть в памяти ведомого, то период становится 110мс. Если ведущего устройства в памяти нет, то период моргания 750мс. После установления связи и на ведущем, и на ведомом устройствах контакт светодиода переходит на высокий уровень.
* Энергопотребление: Во времяустановления связи значение тока изменяется от 30 до 40 мА. Среднее значение составляет 25мА. После установления связи, есть ли передача или нет, ток составляет 8мА.
* Сброс: PIN11, низкий уровень активный.


.Модуль BlueTooth Bee HC-06
image::kr4.png[300, 300]



Модуль имеет следующие контакты:

|===
|PIN | Описание
|PIN1 | Передача UART_TXD , уровень ТТЛ/КМОП, вывод данных UART

|PIN2 | Прием UART_RXD, уровень ТТЛ/КМОП, ввод данных UART

|PIN11 | Сброс модуля. Подача низкого уровня на контакт приведёт к сбросу.

|PIN12 | VCC, напряжение питания. Стандартный уровень напряжения составляет 3,3В, диапазон возможных значений 3,0-4,2В

|PIN13 | GND, заземление
|PIN22 | GND, заземление
|PIN24 | LED, Светодиод, индикатор рабочего режима.
|PIN26 | В случае ведущего устройства контакт обнуляет информацию о запоминаемых устройствах. После обнуления ведущее устройство будет искать ведомое случайным образом. Адрес нового устройства будет записан в память, и в следующий раз в поиске будет только оно.
|===

Для работы HC-06 требует подключения только контактов: UART_TXD, UART_RXD,VCC и GND. +
Однако, рекомендуется подключать также LED и KEY (при использовании в качестве ведущего). +
Передатчик 3,3В TXD платы микроконтроллера соединяется с приемником UART_RXD модуля HC-06, приемник 3,3В RXD платы соединяется с передатчиком UART_TXD модуля HC-06, питание 3,3В и заземление GND. Это — самая простая схема подключения.

*Первое установление связи* У ведущего устройства HC-06 до первого включения память пуста. Если введен верный
пароль, то ведущее устройство автоматически установит связь с ведомым устройством при
первом запуске. Для последующих запусков ведущее устройство запомнит адрес Bluetooth
последнего ведомого и будет осуществлять его поиск. Поиск не заканчивается, пока устройство не
будет найдено. Если на PIN26 ведущего устройства подан высокий уровень, то память будет
очищена. В этом случае, как и при первом запуске, устройство начнёт поиск. Благодаря этой
функции ведущее устройство может устанавливать связь с устройством, имеющим определенный
адрес.



=== Формат вывода:

"Давление: " XXX.XX [мм рт.ст.] +
"Влажность: " XXX.XX [%] +
"Температура: " XXX.XX [℃] +
"Точка росы": " XXX.XX [℃] +

=== Для подключения модуля BlueTooth должна использоваться плата Accessories Shield или I/O Expansion Shield

Accessory Shield - это плата расширения совместимая с популярными платформами для разработки электронных приложений, такими как Arduino UNO, Arduino Leonardo, NUCLEO, XNUCLEO и совместимыми. +
Особенности:

* Разъем расширения для подключения плат Arduino;
* Разъем XBee для подключения беспроводных модулей;
* Индикатор состояния XBee;
* Индикатор питания;
* Кнопка сброса модулей XBee и Arduino;

Компиляция и загрузка программы:

1) Включите загрузочный режим платы разработки UNO PLUS и установите VCC на 5 В; +
2) Подключите дополнительный модуль Shield к плате разработки UNO PLUS, а затем
плату разработки к вашему ПК с помощью USB-кабеля. Вы можете видеть, что индикатор питания на
модуле загорается, когда модуль работает правильно. +
3) В этом документе представлен метод компиляции и загрузки программы с помощью демо
-версии, предоставленной Arduino IDE. Нажмите Файл -> Пример -> 01.Основы -> Мигнуть, чтобы открыть демонстрацию. +


Интерфейс XBee: XBee от MaxStream - это модуль беспроводной связи, основанный на технологии ZigBee. Благодаря
простому в использовании дизайну он может автоматически передавать введенные данные на другой модуль XBee по
беспроводному соединению. И он также поддерживает AT-команды для предварительной настройки. +
Установите Дополнительные защитные перемычки: +
 Подключите TXD к TX; +
 Подключите RXD к RX. +

Заводские настройки модуля XBee по умолчанию следующие: 

* Скорость передачи данных в бодах: 9600;
* Data Bits: 8;
* Flow Control: NONE;
* Parity: NONE;
* Stop Bits: 1.

.Плата Accessories Shield
image::kr9.png[400, 400]

*IO Expansion Shield* - это Arduino плата расширения для удобного подключения сенсоров и беспроводных модулей серии BEE. +
Особенности:

* Интерфейс для подключения сенсоров 3-пин и 4-пин;
* Разъем XBee;
* Разъем для модуля WIFI-LPT100.

Установленные компоненты/интерфейсы на плате:

* Разъем для подключения модулей XBee;
* IIC интерфейс;
* SPI интерфейс;
* Сенсор интерфейс 3-пин (VCC, GND, digital pin);
* Разъем для подключения модуля WIFI-LPT100;
* Сенсор интерфейс 4-пин (VCC, GND, analog pin, digital pin);
* Джампер конфигурации VCC: 3.3В или 5В;
* Джампер выбора отладка/коммуникация;
* Индикаторы состояния XBee и WIFI-LPT100;
* Кнопки WIFI-LPT100 RELOAD, XBee и WIFI-LPT100 RESET, XBee EASYLINK.

.Плата IO Expansion Shield
image::kr10.png[400, 400]

=== Общение с платной модуля BlueTooth должна осуществляться через USART2

Режим встроенного загрузчика используется для программирования флэш-памяти с использованием интерфейса: USART2 (PD5/PD6) +
В модуле USART можно настраивать следующие параметры:

*	Скорость обмена до 4 мбит/c
*	Контроль четности
*	1 или 2 стоповых битов
*	8 или 9 бит данных
*	Запросы на детектирование ошибок приемо-передачи
*	Прерывания по приему, передачи, ошибкам передачи

Для настройки и работы модуля UART нужны всего несколько регистров 

*	USART_CR1/CR2/CR3 - регистр настройки 1
*	USART_DR - регистр принятого символа (регистр данных)
*	USART_BRR – регистр настройки скорости передачи
*	USART_SR - регистр состояния

*Период вывода информации через BlueTooth модуль должен быть 1 секунда.*


= Приложение должно быть написано на языке С++ с использование компилятора ARM 9.10

Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF. Различные типы памяти могут быть расположены по эти адресам. Обычно микроконтроллер имеет постоянную память, из которой можно только читать (ПЗУ) и оперативную память, из которой можно читать и в которую можно писать (ОЗУ). Также часть адресов этой памяти отведены под регистры управления и регистры периферии. +
Микроконтроллер на ядре Cortex M4 выполнен по Гарвардской архитектуре, память здесь разделена на три типа:

*	*ПЗУ* (FLASH память в которой храниться программа)
*	*ОЗУ* память для хранения временных данных (туда же можно по необходимости переместить программу и выполнить её из ОЗУ), память в которой находятся регистры отвечающие за настройку и работу с периферией и
*	Память для хранения постоянных данных ЕЕPROM.

Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера. 

Семейство ARM9 core состоит из ARM9TDMI, ARM940T, ARM9E-S, ARM966E-S, ARM920T, ARM922T, ARM946E-S, ARM9EJ-S, ARM926EJ-S, ARM968E-S, ARM996HS. +
Версия 9.10 полного набора инструментов разработки IAR Embedded Workbench for Arm добавляет поддержку 64-битных ядер Arm, включая Arm Cortex-A35, Cortex-A53, Cortex-A55, Cortex-A57 и Cortex-A72.

= При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и С++ обертка над ней

FreeRTOS – бесплатная многозадачная операционная система реального времени (ОСРВ) для встраиваемых систем. Портирована на 35 микропроцессорных архитектур. +
Планировщик системы очень маленький и простой, однако можно задать различные приоритеты процессов, вытесняющую и не вытесняющую многозадачность. Ядро системы умещается в 3 -4 файлах. +
FreeRTOS межзадачная коммуникация (упорядоченная передача информации от одной задачи другой задаче)

*	События (Как только событие произошло - задача ожидающая это событие переходи в состояние ГОТОВНОСТИ и планировщик в зависимости от приоритета запускает её на исполнение)
*	Очереди
*	Нотификация задачи

Так как мы будем работать именно с FreeRTOS, то надо подключить бибилиотеку: #include "rtos.hpp"

