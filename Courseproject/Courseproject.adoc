:imagesdir: Images
:figure-caption: Рисунок
:table-caption: Таблица
= Курсовой проект
:toc:
:toc-title: Оглавление:

Тема работы: *Разработка метеостанции с передачей параметров по беспроводному интерфейсу*

Чепульская О.С., Яковенко А.Д. КЭ-413 +

= Задание на курсовой проект 

Для разработки должна использоваться отладочная плата  *XNUCLEO-F411RE*. +

Питание платы должно быть автономным и подаваться с солнечный батарей. +

Программное обеспечение измерение должно измерять давление, влажность и температуру и рассчитывать точку росы:

* Период измерения должен быть 100 ms.
* Для измерения давления, влажности и температуры должен использоваться датчик *BME280*
* Общение с датчиком должно осуществляться по интерфейсу SPIx (где х - любой не равный 1,2,3)
* Точка росы должна считаться на основе текущих показаний влажности и давления

Передача значений по беспроводному интерфейсу должна осуществляться через модуль BlueTooth Bee *HC-06*

* Формат вывода: +
"Давление:" XXX.XX [Units] +
"Влажность:" XXX.XX [Units] +
"Температура:" XXX.XX [Units] +
"Точка росы":" XXX.XX [Units] +

* Для подключения модуля BlueTooth должна использоваться плата *Accessories* *Shield* или I/O Expansion Shield
* Общение с платной модуля BlueTooth должна осуществляться через USART2
* Период вывода информации через BlueTooth модуль должен быть 1 секунда.

Архитектура должна быть представлена в виде UML диаграмм в пакете Star UML.

Приложение должно быть написано на языке С++ с использование компилятора ARM 9.10

При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и С++ обертка над ней.


= Анализ требований к разработке


== Для разработки должна использоваться отладочная плата XNUCLEO-F411RE

XNUCLEO-F411RE – это отладочная плата от компании Waveshare с поддержкой Arduino, которая позволит изучить возможности микроконтроллера STM32F411RET6 на базе ядра Cortex-M3.

.Вид платы XNUCLEO-F411RE.
image::kr1.png[300, 300]


== Питание платы должно быть автономным и подаваться с солнечный батарей

Питание будет подаваться с модуля управления солнечной энергией, для панели солнечных батарей 6V~24V. 
Этот модуль управления солнечной энергией может заряжать аккумуляторную литиевую батарею 3.7 V через солнечную панель или USB-соединение и обеспечивает регулируемый выход 5V/1A.

Характеристики:

* Напряжение солнечной панели (SOLAR IN): 6V ~ 24V;
* Зарядные устройства: Солнечная панель, адаптер питания, USB;
* USB-интерфейс зарядки: Micro USB: 5V/1A;
* Внутренняя литий-батарея: 3.7 V 14500 Li-battery;
* Входное напряжение USB: 5V (интерфейс Micro USB);
* Выход 5V: 5V / 1A (USB OUT, GPIO);
* Защита от напряжения отключения заряда: 4.2 V ± 1％;
* Напряжение защиты от перегрузки: 2.9V ± 1％;
* Эффективность заряда солнечной панели: 78%;
* Эффективность зарядки USB: 82%;
* Максимальный ток покоя: <2мА;
* Рабочая температура: -40℃ ~ 85℃.

.Модуль управления солнечной энергией
image::kr2.png[250, 250]

.Способ подключения солнечной батареи
image::kr3.png[500, 500]

== Программное обеспечение измерение должно измерять давление, влажность и температуру и рассчитывать точку росы.


*Период измерения должен быть 100 ms.*

=== Для измерения давления, влажности и температуры должен использоваться датчик BME280

*BME280* – высокоточный метеодатчик, измеряющий такие параметры микроклимата как температура, влажность и атмосферное давление. +
В зависимости от модуля может подключаться к I2C и SPI шинами микроконтроллера и работать от 3-5V, если на плате есть стабилизатор, или 3V, если его нет. +
Данный модуль работает по двухпроводному интерфейсу I2C, адрес по умолчанию 0x76, но есть возможность изменить на адрес 0x77. Модуль подключается на шину I2C и питание, как и любой другой модуль такого типа. +

Примеры библиотек для работы с датчиком:

* Adafruit BME280 (для работы также нужна Adafruit Sensor) – самая известная библиотека для работы с BME280. Часть настроек доступна только при ручном редактировании библиотеки.
* GyverBME280 –Также поддерживает датчики BMP280

Благодаря сверхмалому форм-фактору, низкому энергопотреблению, высокой точности и стабильности датчик окружающей среды BME280 подходит для таких применений, как мониторинг окружающей среды, прогноз погоды.

*Управление питанием*. BME280 имеет два отдельных вывода источника питания:

* Vdd является основным источником питания для всех внутренних аналоговых и цифровых функциональных блоков;
* Vddio - это отдельный вывод источника питания, используемый для питания цифрового интерфейса.

Встроенный генератор сброса питания (POR), он сбрасывает логическую часть и значения регистра после обоих Vdd и Vddio достигают своих минимальных уровней. Нет никаких ограничений на наклон и последовательность повышения уровней Vdd и Vddio.

*Режимы датчика*. BME280 предлагает три режима работы датчика: 

* Sleep mode: не работает, доступны все регистры, самая низкая мощность, выбирается после запуска;
* Forced mode: выполнит одно измерение, сохранит результаты и вернется в спящий режим;
* Normal mode: непрерывный цикл измерений и периоды бездействия.



=== Общение с датчиком должно осуществляться по интерфейсу SPIx (где х - любой не равный 1,2,3)

Последовательный периферийный интерфейс (SPI) обеспечивает полудуплексную/полнодуплексную синхронную последовательную связь с внешними устройствами. Интерфейс может быть сконфигурирован как ведущий, и в этом случае он обеспечивает синхронизацию связи (SCK) с внешним подчиненным устройством. + 
Интерфейс также способен работать в конфигурации multimaster. Он может использоваться для различных целей, включая симплексную синхронную передачу по двум линиям с возможной двунаправленной линией передачи данных или надежную связь с использованием проверки CRC. +
Интерфейс SPI имеет два режима: 4-проводной и 3-проводной. Протокол одинаков для обоих.




Интерфейс SPI:

|===
|Function pin | STM32 interface | Describe

| VCC		
| 3.3V /5V
| Входная мощность 3.3V

| GND		
| GND
| Земля

| MOSI
| PB5		
| SPI data input

| SCK
| PB3		
| SPI clock input


| MISO
| PB4		
| SPI data output

| CS	
| PB10
| Выбор чипа SPI, активный при низком напряжении

|===



Обычно SPI подключается к внешним устройствам через четыре контакта:

* MISO: Master In / Slave Out data. 
* MOSI: Master Out / Slave In data. 
* SCK: Serial Clock output for SPI masters and input for SPI slaves. (Последовательный тактовый выход для ведущих SPI и вход для ведомых SPI.)
* NSS: Slave select. This is an optional pin to select a slave device. (Выбор ведомого устройства, позволяя ведущему SPI взаимодействовать с подчиненными устройствами индивидуально и избегать конфликтов в линиях передачи данных.)


image::kr12.png[600, 600]

.Структурная схема SPI
image::kr11.png[]


Контакты MOSI и контакты MISO соединены вместе. Таким образом, данные передаются последовательно между ведущим и ведомым (сначала самый значимый бит).

Общение всегда инициируется мастером. Когда ведущее устройство передает данные на подчиненное устройство через вывод MOSI, подчиненное устройство отвечает через вывод MISO. Это подразумевает полнодуплексную связь как с выводом данных, так и с вводом данных, синхронизированных с одним и тем же тактовым сигналом (который обеспечивается главным устройством через вывод SCK).

*Методы SendByte() и ReadByte()* получают и передают данные в буфер.
Регистр данных разделен на 2 буфера - один для записи (буфер передачи) и другой для чтения (буфер приема). Запись в регистр данных приведет к записи в буфер Tx, а считывание из регистра данных вернет значение, хранящееся в буфере Rx.

image::sp1.png[500, 500]

*Методы TransmiteBufEmptyInterruptEnable(), TransmiteBufEmptyInterruptDisable()* отвечают за включение прерывания с пустым буфером Tx.

image::sp2.png[500, 500]

Используется для генерации запроса на прерывание, когда установлен флаг TXE.


*Методы ReceiveBufNotEmptyInterruptEnable() и ReceiveBufNotEmptyInterruptDisable()* отвечают за разрешение прерывания при заполнении буфера RX.

image::sp3.png[500, 500]


*Метод TransmittionCompleted()* отвечает за завершение передачи данных, проверяет происходит ли передача данных и пуст ли Tx буфер.

image::sp4.png[400, 400]

*Метод SpiInterruptHandler* обрабатывает прерывания буфера Rx и Tx и перенаправляет их в методы OnNextByte.


*Методы SendMessage(), SendByte()* отвечают за передачу данных по интерфейсу SPI.

*Методы  IsMessageTransmitted() и IsMessageReceived()* получают и передают  данные.

*Методы  OnNextByteTransmite() и OnNextByteReceive()* отвечают за получение и последующую передачу байтов.

*Методы GetMessage(), GetByte()* отвечают за получение данных и предоставляют доступ на их чтение.

*Метод SetReceivedMesLength* устанавливает длину полученного сообщения. 


Для примера приведём часть инициализации использования SPI для датчика BME280, с использованием библиотеки предоставленной Bosch Sensortec:

[source, cpp]
struct bme280_dev dev;
int8_t rslt = BME280_OK;
/* Sensor_0 interface over SPI with native chip select line */
dev.dev_id = 0;
dev.intf = BME280_SPI_INTF;
dev.read = user_spi_read;
dev.write = user_spi_write;
dev.delay_ms = user_delay_ms;
rslt = bme280_init(&dev);


Среди них bme280_dev - это структура устройства BME280, приведенная в официальной библиотеке. Он используется для инициализации и сбора данных. Реализует следующие функции:

[source, cpp]
user_spi_read()
user_spi_write()
user_delay_ms()


Функция считывания данных BME280:

[source, cpp]
int8_t stream_sensor_data_forced_mode(struct bme280_dev *dev)
int8_t stream_sensor_data_normal_mode(struct bme280_dev *dev)


все вышеперечисленные функции вызывают функцию вывода:

[source, cpp]
void print_sensor_data(struct bme280_data *comp_data)


Идеи реализации функций, чтения SPI, записи SPI заключаются в следующем:


[source, cpp]
void user_delay_ms(uint32_t period)
{
    /*
     * Return control or wait,
     * for a period amount of milliseconds
     */
}
int8_t user_spi_read(uint8_t dev_id, uint8_t reg_addr, uint8_t *reg_data, uint16_t len)
{
    int8_t rslt = 0; /* Return 0 for Success, non-zero for failure */
    /*
     * The parameter dev_id can be used as a variable to select which Chip Select pin has
     * to be set low to activate the relevant device on the SPI bus
     */
    /*
     * Data on the bus should be like
     * |----------------+---------------------+-------------|
     * | MOSI           | MISO                | Chip Select |
     * |----------------+---------------------|-------------|
     * | (don't care)   | (don't care)        | HIGH        |
     * | (reg_addr)     | (don't care)        | LOW         |
     * | (don't care)   | (reg_data[0])       | LOW         |
     * | (....)         | (....)              | LOW         |
     * | (don't care)   | (reg_data[len - 1]) | LOW         |
     * | (don't care)   | (don't care)        | HIGH        |
     * |----------------+---------------------|-------------|
     */
    return rslt;
}
int8_t user_spi_write(uint8_t dev_id, uint8_t reg_addr, uint8_t *reg_data, uint16_t len)
{
    int8_t rslt = 0; /* Return 0 for Success, non-zero for failure */
    /*
     * The parameter dev_id can be used as a variable to select which Chip Select pin has
     * to be set low to activate the relevant device on the SPI bus
     */
    /*
     * Data on the bus should be like
     * |---------------------+--------------+-------------|
     * | MOSI                | MISO         | Chip Select |
     * |---------------------+--------------|-------------|
     * | (don't care)        | (don't care) | HIGH        |
     * | (reg_addr)          | (don't care) | LOW         |
     * | (reg_data[0])       | (don't care) | LOW         |
     * | (....)              | (....)       | LOW         |
     * | (reg_data[len - 1]) | (don't care) | LOW         |
     * | (don't care)        | (don't care) | HIGH        |
     * |---------------------+--------------|-------------|
     */
    return rslt;
}

Подводя итог, на основе официальной библиотеки, основной процесс получения данных BME280 для различных платформ выглядит следующим образом: + 
*Шаг 1:* Инициализация системы и периферийных устройств. +
*Шаг 2:* Реализуйте функции чтения SPI, записи SPI, задержки на разных платформах, назначьте указатель функции переменной-члену структуры bme280_dev и передайте указатель структуры для инициализации и после этого можно инициализировать устройство BME280. +
*Шаг 3:* Вызов функции int8_t stream_sensor_data_forced_mode(struct bme280_dev *dev) или функции int8_t stream_sensor_data_normal_mode(struct bme280_dev *dev), получая данные датчика BME280 и выводит их на главный компьютер или консоль. +






=== Точка росы должна считаться на основе текущих показаний влажности и давления

В данном курсовом проекте необходимо рассчитать и вывести точку росы.

Температура точки росы газа (точка росы) — значение температуры газа, при которой водяной пар, содержащийся в газе, охлаждаемом изобарически, становится насыщенным над плоской поверхностью воды.

Точка росы – это температура воздуха, при которой содержащийся в нём пар достигает состояния насыщения и начинает конденсироваться в росу.

*Точка росы бывает двух видов*: точка росы под давлением и атмосферная точка росы.

*1. Точка росы под давлением [°Cтрд]*

Точка росы под давлением [°Cтрд] - это температура, до которой сжатый воздух может быть охлажден без образования конденсата. Точка росы зависит от давления процесса. Когда давление падает, точка росы также снижается.

Говоря о системах под давлением, мы имеем в виду точку росы под давлением, но не атмосферную точку росы. Описание различий между этими двумя физическими параметрами приводится ниже.

*2. Атмосферная точка росы [°CtdA]*

Атмосферная точка росы [°CтрА] – температура, до которой атмосферный воздух (воздух под давлением приблиз. 1 бар абс.) может быть охлажден без образования конденсата.
В требованиях не сказано какая точка росы необходима.

При анализе точки росы под давлением было выяснено, что данная точка расчитывается путем диаграмм Молье. +
Традиционные психрометрические диаграммы верны только при одном уровне давления, обычно при атмосферном давлении (применение в области технологий кондиционирования воздуха, см. “Стационарные технологии для измерения влажности, дифференциального давления и температуры”). +
Психрометрическая диаграмма ниже показывает соотношение разных переменных влажности (точка росы [°Cтр],относительная влажность [%ОВ] и степень влажности [г/кг] также, как и температура [°C] ) в том числе при неатмосферном давлении. +

.Диаграмма Молье
image::kr5.png[500, 500]


Так как данное преобразование занимает больше времени, чем отводится на реализацию проекта, было установлено, что расчет будет проводится только атмосферной точки росы. +
Формула для приблизительного расчёта точки росы в градусах Цельсия (только для положительных температур):

image::kr6.png[]

где: +
a = 17,27, +
b= 237,7 °C, +

image::kr8.png[170, 170]

Т - температура в градусах Цельсия, +
RH - относительная влажность в объёмных долях (0 < RH < 1,0). +

Формула обладает погрешностью ±0,4 °C в следующем диапазоне значений:

0 °C <T < 60 °C +
0,01 < RH < 1,00 +
0 °C < T, < 50 °C +


Существует более простая формула для приблизительного расчёта, дающая погрешность ±1,0 °C при относительной влажности в объёмных долях более 0,5. +
Эту формулу можно использовать для вычисления относительной влажности по известной точке росы. +
При анализе выяснено, что расчет идет а.т.р. так как диаграммы молье сложны для реализации в короткие сроки, потому что необходима интерполяция и аппроксимация функций, а также из-за отсутствия условий на диапазон используемого давления, мы не можем определить нужные нам функции для работы с точкой росы под давлением. +
 

== Передача значений по беспроводному интерфейсу должна осуществляться через модуль BlueTooth Bee HC-06

Беспроводной модуль для приема/передачи данных в Arduino проектах по протоколу Bluetooth.

Особенности:

* Поддерживает работу с любым USB Bluetooth адаптером;
* Скорость передачи данных: 9600 бит/сек;
* Встроенная антенна;
* Радиус действия до 10 метров.
* Питание 3,3В – 6 В;
* Скорость передачи данных 1200–1382400 бод;
* Рабочие частоты 2,40 ГГц – 2,48ГГц;


Модуль HC-06 используется только в режиме slave, то есть он не может самостоятельно подключаться к другим устройствам Bluetooth. Все настройки для подключения «пароль, скорость передачи данных» можно изменить при помощи АТ-команд.


Основная функция модуля Bluetooth - это организация связи по последовательному интерфейсу там, где ранее для связи применялась кабельная линия.

Основные заводские параметры HC-06:

* *Режим ведущего:* имеет встроенную память, для запоминания последнего связанного ведомого устройства. Устанавливает связь только если на контакт (PIN26) подан низкий уровень. По умолчанию на PIN26 установлен низкий уровень.
* *Установка связи:* ведущее устройство осуществляет поиск и соединение с ведомым автоматически.
* *Основной метод:* при выполнении некоторых условий, ведущее и ведомые устройства соединяются автоматически.
* *AT режим:* До установления связи устройство работает в режиме AT. После установления связи с другим устройством идёт прямая передача информации.
* Во время установления связи модуль не может входить в режим AT.
* *Скорость* по умолчанию — 9600.
* Светодиод LED: Период мигания ведомого устройства — 102мс. Если ведущее устройство уже есть в памяти ведомого, то период становится 110мс. Если ведущего устройства в памяти нет, то период моргания 750мс. После установления связи и на ведущем, и на ведомом устройствах контакт светодиода переходит на высокий уровень.
* Энергопотребление: Во времяустановления связи значение тока изменяется от 30 до 40 мА. Среднее значение составляет 25мА. После установления связи, есть ли передача или нет, ток составляет 8мА.
* Сброс: PIN11, низкий уровень активный.


.Модуль BlueTooth Bee HC-06
image::kr23.png[300, 300]



Модуль имеет следующие контакты:

|===
|PIN | Описание
|PIN1 | Передача UART_TXD , уровень ТТЛ/КМОП, вывод данных UART

|PIN2 | Прием UART_RXD, уровень ТТЛ/КМОП, ввод данных UART

|PIN11 | Сброс модуля. Подача низкого уровня на контакт приведёт к сбросу.

|PIN12 | VCC, напряжение питания. Стандартный уровень напряжения составляет 3,3В, диапазон возможных значений 3,0-4,2В

|PIN13 | GND, заземление
|PIN22 | GND, заземление
|PIN24 | LED, Светодиод, индикатор рабочего режима.
|PIN26 | В случае ведущего устройства контакт обнуляет информацию о запоминаемых устройствах. После обнуления ведущее устройство будет искать ведомое случайным образом. Адрес нового устройства будет записан в память, и в следующий раз в поиске будет только оно.
|===

Для работы HC-06 требует подключения только контактов: UART_TXD, UART_RXD,VCC и GND. +
Однако, рекомендуется подключать также LED и KEY (при использовании в качестве ведущего). +
Передатчик 3,3В TXD платы микроконтроллера соединяется с приемником UART_RXD модуля HC-06, приемник 3,3В RXD платы соединяется с передатчиком UART_TXD модуля HC-06, питание 3,3В и заземление GND. Это — самая простая схема подключения.

*Первое установление связи* У ведущего устройства HC-06 до первого включения память пуста. Если введен верный
пароль, то ведущее устройство автоматически установит связь с ведомым устройством при
первом запуске. Для последующих запусков ведущее устройство запомнит адрес Bluetooth
последнего ведомого и будет осуществлять его поиск. Поиск не заканчивается, пока устройство не
будет найдено. Если на PIN26 ведущего устройства подан высокий уровень, то память будет
очищена. В этом случае, как и при первом запуске, устройство начнёт поиск. Благодаря этой
функции ведущее устройство может устанавливать связь с устройством, имеющим определенный
адрес.


=== Формат вывода:

"Давление: " XXX.XX [Units] +
"Влажность: " XXX.XX [Units] +
"Температура: " XXX.XX [Units] +
"Точка росы": " XXX.XX [Units] +

=== Для подключения модуля BlueTooth должна использоваться плата Accessories Shield или I/O Expansion Shield

В нашем проекте, мы будем использовать плату расширения *Accessory* *Shield*

Accessory Shield - это плата расширения совместимая с популярными платформами для разработки электронных приложений, такими как Arduino UNO, Arduino Leonardo, NUCLEO, XNUCLEO и совместимыми. +
Особенности:

* Разъем расширения для подключения плат Arduino;
* Разъем XBee для подключения беспроводных модулей;
* Индикатор состояния XBee;
* Индикатор питания;
* Кнопка сброса модулей XBee и Arduino;

Компиляция и загрузка программы:

1) Включите загрузочный режим платы разработки UNO PLUS и установите VCC на 5 В; +
2) Подключите дополнительный модуль Shield к плате разработки UNO PLUS, а затем
плату разработки к вашему ПК с помощью USB-кабеля. Вы можете видеть, что индикатор питания на
модуле загорается, когда модуль работает правильно. +
3) В этом документе представлен метод компиляции и загрузки программы с помощью демо
-версии, предоставленной Arduino IDE. Нажмите Файл -> Пример -> 01.Основы -> Мигнуть, чтобы открыть демонстрацию. +


Интерфейс XBee: XBee от MaxStream - это модуль беспроводной связи, основанный на технологии ZigBee. Благодаря
простому в использовании дизайну он может автоматически передавать введенные данные на другой модуль XBee по
беспроводному соединению. И он также поддерживает AT-команды для предварительной настройки. +
Установите Дополнительные защитные перемычки: +
 Подключите TXD к TX; +
 Подключите RXD к RX. +

Заводские настройки модуля XBee по умолчанию следующие: 

* Скорость передачи данных в бодах: 9600;
* Data Bits: 8;
* Flow Control: NONE;
* Parity: NONE;
* Stop Bits: 1.

.Плата Accessories Shield
image::kr9.png[400, 400]


=== Общение с платной модуля BlueTooth должна осуществляться через USART2

Режим встроенного загрузчика используется для программирования флэш-памяти с использованием интерфейса: USART2 (PD5/PD6) +
В модуле USART можно настраивать следующие параметры:

*	Скорость обмена до 4 мбит/c
*	Контроль четности
*	1 или 2 стоповых битов
*	8 или 9 бит данных
*	Запросы на детектирование ошибок приемо-передачи
*	Прерывания по приему, передачи, ошибкам передачи

Для настройки и работы модуля UART нужны всего несколько регистров 

*	USART_CR1/CR2/CR3 - регистр настройки 1
*	USART_DR - регистр принятого символа (регистр данных)
*	USART_BRR – регистр настройки скорости передачи
*	USART_SR - регистр состояния

*Период вывода информации через BlueTooth модуль должен быть 1 секунда.*


== Приложение должно быть написано на языке С++ с использование компилятора ARM 9.10

Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF. Различные типы памяти могут быть расположены по эти адресам. Обычно микроконтроллер имеет постоянную память, из которой можно только читать (ПЗУ) и оперативную память, из которой можно читать и в которую можно писать (ОЗУ). Также часть адресов этой памяти отведены под регистры управления и регистры периферии. +
Микроконтроллер на ядре Cortex M4 выполнен по Гарвардской архитектуре, память здесь разделена на три типа:

*	*ПЗУ* (FLASH память в которой храниться программа)
*	*ОЗУ* память для хранения временных данных (туда же можно по необходимости переместить программу и выполнить её из ОЗУ), память в которой находятся регистры отвечающие за настройку и работу с периферией и
*	Память для хранения постоянных данных ЕЕPROM.

Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера. 

Семейство ARM9 core состоит из ARM9TDMI, ARM940T, ARM9E-S, ARM966E-S, ARM920T, ARM922T, ARM946E-S, ARM9EJ-S, ARM926EJ-S, ARM968E-S, ARM996HS. +
Версия 9.10 полного набора инструментов разработки IAR Embedded Workbench for Arm добавляет поддержку 64-битных ядер Arm, включая Arm Cortex-A35, Cortex-A53, Cortex-A55, Cortex-A57 и Cortex-A72.

== При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и С++ обертка над ней

FreeRTOS – бесплатная многозадачная операционная система реального времени (ОСРВ) для встраиваемых систем. Портирована на 35 микропроцессорных архитектур. +
Планировщик системы очень маленький и простой, однако можно задать различные приоритеты процессов, вытесняющую и не вытесняющую многозадачность. Ядро системы умещается в 3 -4 файлах. +
FreeRTOS межзадачная коммуникация (упорядоченная передача информации от одной задачи другой задаче)

*	События (Как только событие произошло - задача ожидающая это событие переходи в состояние ГОТОВНОСТИ и планировщик в зависимости от приоритета запускает её на исполнение)
*	Очереди
*	Нотификация задачи

Так как мы будем работать именно с FreeRTOS, то надо подключить бибилиотеку: #include "rtos.hpp"



= Функциональная схема

Приведём функциональную схему устройства, составленной на основе требований технического задания.


.Функциональная схема устройства
image::kr45.png[]

Функциональная схема устройства состоит из следующих блоков:

*	микроконтроллер STM32F411RE;
*	датчик BME280;
*	плата расширения с подключенным к ней Bluetooth-модулем;
*	кнопка выбора единицы измерения температуры;
*	программатор.


= Схема электрическая принципиальная

Приведём электрическую схему, составленной на основе используемых устройств.

.Схема электрическая принципиальная
image::kr25.png[]

.Перечень элементов
image::kr46.png[]

= Архитектура проекта 

==	Общая архитектура проекта

Общая архитектура проекта, выполненная в программе StarUML

.Общая архитектура проекта
image::kr26.png[]

.Диаграмма
image::kr28.png[700, 700]

== Детальная архитектура

.Общая архитектура проекта
image::kr27.png[]

= Классы

== Класс Measurement

Класс Measurement, описывающий значения измеряемых величин, имеет следующие компоненты:

*	DataSourceFcn - указатель на функцию-поставщик данных;
*	units - массив единиц измерения, используемых для выражения значения этой величины;
*	countOfUnit - длина массива unit;
*	defaultUnit - исходная единица измерения, в которой выражены значения, поставляемые источником данных DataSourceFcn;
*	GetValue() - функция, возвращающая выраженное в defaultUnit значение измеряемой величины;
*	GetValue(unit) - функция, возвращающая значение измеряемой величины, выраженное в выбранной единице измерения unit;
*	quantityName - сторка наименования измеряемой величины;
*	ShowUnitName(unit) - статическая функция, возвращающаяя строку обозначения единицы измерения unit.
*	конструктор, создающий экземпляр класса на основе названия измеряемой величины, массива допустимых единиц измерений, длины этого массива, исходной величины измерения, указателя на функцию-поставщика данных;
*	упрощенный конструктор для величин с одной допустимой единицей измерения, создающий экземпляр класса на основе названия измеряемой величины, единицы измерения, указателя на функцию-поставщика данных.

На рисунке приведены диаграммы класса Measurement, а также экземпляры этих классов temperature, pressure, humidity, dewPoint, указатели на которые объединены в массив measurements.

image::kr29.png[600, 600]

=== Код класса Measurement

==== measurement.h

[source, cpp]
#include <string>
#include <cassert>
#pragma once
enum class Unit
{
C,
hPa,
percent
};
class Measurement
{
protected:
double(*DataSourceFcn)();
public:  
const Unit *const units;
const std::size_t countOfUnits;
const Unit defaultUnit;
std::string quantityName;
Measurement(std::string quantityName, Unit* units, std::size_t countOfUnits, Unit defaultUnit, double(*DataSourceFcn)()):
quantityName(quantityName),units(units), countOfUnits(countOfUnits),defaultUnit(defaultUnit), DataSourceFcn(DataSourceFcn)
{
assert(CheckUnit(defaultUnit) &&" defalt unit must match measurement's units");
}
Measurement(std::string quantityName, Unit unit, double(*DataSourceFcn)()):
quantityName(quantityName),defaultUnit(unit),units(&defaultUnit), countOfUnits(1), DataSourceFcn(DataSourceFcn)
{
}
virtual double GetValue()
{
return DataSourceFcn();
}
virtual double GetValue(Unit unit)
{
assert(CheckUnit(unit)&&" defalt unit must match measurement's units");
return DataSourceFcn();
}
bool CheckUnit(Unit unit)
{
bool flag=false;
for(int i=0;i<countOfUnits;i++)
{
if(unit==units[i])
{
flag=true;
}
}
return flag;
}
static string ShowUnitName(Unit unit)
{
string str;
switch(unit)
{  
case Unit::C:
str = "C";
break;
case Unit::hPa:
str = "hPa";
break;
case Unit::percent:
str = "%";
break;  
default:
assert(false &&" unit must match measurement's units");
break;
}
return str;
}
};

==== measurementConfig.h

[source, cpp]
#pragma once
#include "Measurement.h"
#include "Temperature.h"
#include "bme280driverconfig.h"
double fcnTemp()
{
return bme280.GetTemperature();
};
double fcnPress()
{
return bme280.GetPressure();
};
double fcnHum()
{
return bme280.GetHumidity();
};
double fcnDewP()
{
return bme280.GetDewPoint();
};
inline Temperature temperature("Temperature", fcnTemp);
inline Measurement pressure("Pressure", Unit::hPa, fcnPress);
inline Measurement humidity("Humidity", Unit::percent, fcnHum);
inline Temperature dewPoint("Dew point",  fcnDewP);
inline Measurement* measurements[4] = {&temperature, &pressure, &humidity, &dewPoint};
inline Unit userUnits[4]={Unit::F, Unit::hPa, Unit::percent, Unit::F};


==	Класс BME280Driver

Класс bme280 используется для взаимодействия с датчиком BME280:

*	метод StartMeasurements() запускает измерения датчика с передискретизацией 1, устонавливает режим работы normal;
*	метод InitializeCalibrateData() считывает калибровочные коэффициенты.
*	метод Measure() обновляет поля temperature, pressure, humidity, dewPoint в соответствии с возвращаемыми значениями методов ReadTemperature(), ReadPressure(), ReadHumidity(), CalcDewPoint();
*	Методы ReadTemperature(), ReadPressure(), ReadHumidity() отвечают за чтение «сырых» данных из регистров датчика и последующие введение поправок в соответствии с рекомендациями производителя датчика;
*	Методы GetTemperature(), GetPressure(), GetHumidity(), GetDewPoint() предоставляют доступ на чтение полей temperature, pressure,humidity, dewPoint.

.Диаграмма класса BME280Driver
image::kr30.png[400, 400]

Наиболее существенной задачей, решенной при разработке BME280Driver, является задача чтения компенсационных параметров из регистров датчика и компенсация с их помощью систематических погршностей сырых данных датчика. На рисунке приводятся регистры датчика, в которых записаны компенсационные параметры (Table 16) и регистры управления режимом измерений (Tables 19, 22):

image::kr31.png[]
  
.Регистры с компенсационными параметрами
image::kr32.png[]

Ниже приведены компенсационные формулы, рекомендованные  производителем:

image::kr33.png[]

image::kr34.png[]

image::kr35.png[]

=== Код класса BME280Driver

==== BME280Driver.h

[source, cpp]
#pragma once
#include "spiDriver.h"
#include "math.h"
constexpr char ReadModeMask = 0x80;
constexpr char WriteModeMask = 0x7F;
struct BME280Registers
{
  enum: char
  {
    Id=0xD0,
    Calibrate=0x88,
    SoftReset = 0xE0, //BME280 SOFT RESET REGISTER
    Status=0xF3,  //BME280 STATUS REGISTER
    Config=0xF5,  // Configuration register
    PressureData=0xF7,
    TemperatureData=0xFA,
    HumidityData=0xFD,
    CalibrateDigH1 = 0xA1,
    CalibrateDigH2 = 0xE1,
    CalibrateDigH4 = 0xE4,
    CalibrateDigH4H5 = 0xE5,
    CalibrateDigH5 = 0xE6,
    CalibrateDigH6 = 0xE7,
    CtrlHumidityMeasurement = 0xF2,
    CtrlMeasurements=0xF4
  };
};
struct BME280RegisterValues 
{
enum: char
{
  Id = 0x60, //BME280 ID
  StatusMeasuring = 0x08, //Running conversion
  StatusImUpdate = 0x01, //NVM data copying
  SoftReset = 0xB6, //BME280 SOFT RESET VALUE
  SingleHumidityMeasurementMode=0x1,
  SingleMeasurementsStart =  0x20|0x4|0x3
};
};
template<auto& spiDriver,typename CSPin>
class BME280Driver
{
  struct
  {
    uint16_t dig_T1;   
    int16_t dig_T2;    
    int16_t dig_T3;    
    uint16_t dig_P1;    
    int16_t dig_P2;    
    int16_t dig_P3;    
    int16_t dig_P4;    
    int16_t dig_P5;    
    int16_t dig_P6;    
    int16_t dig_P7;    
    int16_t dig_P8;    
    int16_t dig_P9;    
    uint8_t dig_H1;    
    int16_t dig_H2;   
    uint8_t dig_H3;    
    int16_t dig_H4;    
    int16_t dig_H5;    
    int8_t dig_H6;   
  } __attribute__((packed)) calibStruct;  
  double temperature;
  double pressure;
  double humidity;
  double dewPoint;
  uint32_t tempInt=138347U;
  uint32_t pressInt;  
public:
  BME280Driver()
  {
    CSPin::Set();
  }
  double GetTemperature()
  {
    return temperature;
  }
  double GetPressure()
  {
    return pressure;
  }
  double GetHumidity()
  {
    return humidity;
  }
  double GetDewPoint()
  {
    return dewPoint;
  }
  char ReadRegister(char byte)
  {
    CSPin::Reset();
    spiDriver.SetReceivedMesLength(1);
    spiDriver.SendByte(((char)byte)|ReadModeMask);
    while(!spiDriver.IsMessageReceived())
    {}
    CSPin::Set();
    return spiDriver.GetByte();
  }  
  void WriteRegister(char address, char regdata)
  {
    spiDriver.SetReceivedMesLength(0);
    char mes[2]={address & WriteModeMask,regdata};
    CSPin::Reset();
    spiDriver.SendMessage(mes,2);
    CSPin::Set();
  } 
  void ReadSpanOfRegisters(char firstAddress, char* outBuf, std::size_t length)
  {
    spiDriver.SetReceivedMesLength(length);
    CSPin::Reset();
    spiDriver.SendByte(firstAddress|ReadModeMask);
    while(!spiDriver.IsMessageReceived())
    {}
    CSPin::Set();
    spiDriver.GetMessage(outBuf);
  } 
  void InitializeCalibrateData()
  {
    ReadSpanOfRegisters(BME280Registers::Calibrate,reinterpret_cast<char*>(&calibStruct), 24);
    calibStruct.dig_H1=ReadRegister(BME280Registers::CalibrateDigH1);
    ReadSpanOfRegisters(BME280Registers::CalibrateDigH2,reinterpret_cast<char*>(&calibStruct.dig_H2), 3);
    short byteDigH4 = ReadRegister(BME280Registers::CalibrateDigH4);
    short byteDigH4H5 = ReadRegister(BME280Registers::CalibrateDigH4H5);
    short byteDigH6 = ReadRegister(BME280Registers::CalibrateDigH5);
    calibStruct.dig_H4 = (byteDigH4<<4)|(byteDigH4H5&0x0F);
    calibStruct.dig_H5 = (byteDigH6<<4)|((byteDigH4H5&0xF0)>>4);
    calibStruct.dig_H6 = ReadRegister(BME280Registers::CalibrateDigH6);
  }
  void StartMeasurements()
  {
    WriteRegister(BME280Registers::CtrlHumidityMeasurement,BME280RegisterValues::SingleHumidityMeasurementMode);//hum
    WriteRegister(BME280Registers::CtrlMeasurements,BME280RegisterValues::SingleMeasurementsStart);//temp and press
  }
  void Reset()
  {
    WriteRegister(BME280Registers::SoftReset,BME280RegisterValues::SoftReset);
    while(ReadRegister(BME280Registers::Status)&0x9&((char)BME280RegisterValues::StatusImUpdate));
  }  
  void Measure()
  {
    temperature = ReadTemperature();
    pressure = ReadPressure();
    humidity =ReadHumidity();
    dewPoint =CalcDewPoint();
  }
  float ReadTemperature()
  {
    char pTemp[3] = {0};
    ReadSpanOfRegisters(BME280Registers::TemperatureData,pTemp, 3);
    uint32_t tempRaw = (pTemp[0]<<16)+(pTemp[1]<<8)+pTemp[2];
    tempRaw>>=4;
    int32_t val1 = ((((tempRaw>>3) - ((int32_t) calibStruct.dig_T1 <<1))) *                    
                    ((int32_t) calibStruct.dig_T2)) >> 11;    
    int32_t val2 = (((((tempRaw>>4) - ((int32_t) calibStruct.dig_T1)) *                     
                      ((tempRaw>>4) - ((int32_t) calibStruct.dig_T1))) >> 12) *                   
                    ((int32_t) calibStruct.dig_T3)) >> 14;    
    uint32_t tempInt = val1 + val2;
    float tempFloat = ((tempInt * 5 + 128) >> 8);
    tempFloat /= 100.0f;
    return tempFloat;
  } 
  float ReadPressure()
  {
    char pPress[3] = {0};
    ReadSpanOfRegisters(BME280Registers::PressureData,pPress, 3);
    uint32_t pressRaw = (pPress[0]<<16)+(pPress[1]<<8)+pPress[2];
    pressRaw >>= 4; 
    int64_t val1 = ((int64_t) tempInt) - 128000;   
    int64_t val2 = val1 * val1 * (int64_t)calibStruct.dig_P6;    
    val2 = val2 + ((val1 * (int64_t)calibStruct.dig_P5) << 17);    
    val2 = val2 + ((int64_t)calibStruct.dig_P4 << 35);    
    val1 = ((val1 * val1 * (int64_t)calibStruct.dig_P3) >> 8) + ((val1 * (int64_t)calibStruct.dig_P2) << 12);    
    val1 = (((((int64_t)1) << 47) + val1)) * ((int64_t)calibStruct.dig_P1) >> 33;    
    if (val1 == 0) {      
      return 0;      
    }    
    int64_t p = 1048576 - pressRaw;    
    p = (((p << 31) - val2) * 3125) / val1;    
    val1 = (((int64_t)calibStruct.dig_P9) * (p >> 13) * (p >> 13)) >> 25;    
    val2 = (((int64_t)calibStruct.dig_P8) * p) >> 19;   
    p = ((p + val1 + val2) >> 8) + ((int64_t)calibStruct.dig_P7 << 4);    
    pressInt = p; //((p >> 8) * 1000) + (((p & 0xff) * 390625) / 100000);    
    float pressFloat = p;
    pressFloat = pressFloat/ 25600;
    return pressFloat;
  }  
  float ReadHumidity()
  {
    char pHumid[2] = {0};
    ReadSpanOfRegisters(BME280Registers::HumidityData,pHumid, 2);
    uint16_t humidRaw = (pHumid[0]<<8)+pHumid[1];
    int32_t humidRawSign = ((int32_t)humidRaw)&0x0000FFFF;
    int32_t v_x1_u32r = (tempInt - ((int32_t)76800));  
    v_x1_u32r = (((((humidRawSign << 14) - (((int32_t)calibStruct.dig_H4) << 20) -                  
                    (((int32_t)calibStruct.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *                
                 (((((((v_x1_u32r * ((int32_t)calibStruct.dig_H6)) >> 10) *                     
                      (((v_x1_u32r * ((int32_t)calibStruct.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +                    
                   ((int32_t)2097152)) * ((int32_t)calibStruct.dig_H2) + 8192) >> 14));    
    v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) *                              
                               ((int32_t)calibStruct.dig_H1)) >> 4));   
    v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r;  
    v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r; 
    float humidFloat = (v_x1_u32r>>12);//humidRaw;  
    humidFloat /= 1024.0f;
    return humidFloat;
  }  
  float CalcDewPoint()
  {
    float a = 17.27;
    float b = 237.7;
    float T = temperature;
    float RH = humidity/100;
    float gamma = a*T/(b+T)+log(RH);
    float Tp = b*gamma/(a-gamma);
    return Tp;
  }  
};

==== BME280DriverConfig.h

[source, cpp]
 #pragma once
#include "BME280Driver.h"
#include "spiconfig.h"
#include "pinsconfig.h"
inline BME280Driver<spi1Transceiver, PinCSforBME280> bme280;

== Классы USART, UsartDriver

В классе USART<USARTx, tranceiver> содержатся методы, оборачивающие работу с регистрами USARTx микроконтроллера, и обработчик прерываний USARTx, в котором вызываются методы драйвера tranceiver, содержащие конкретную логику действий, которые требуется совершить при прерываниях RXNE (буфер приема не пуст), TXE (буфер передачи пуст).

Класс UsartDriver<USART> предоставляет возможность передачи и чтения данных по интерфейсу USART. Момент завершения приема входного сообщения фиксируется по наступлению прерывания.

image::kr36.png[]

=== Код классов USART и UsartDriver

==== usart.h

[source, cpp]
#pragma once
#include "usart2registers.hpp"
#include "usart1registers.hpp"
struct UsartConfig
{
UsartConfig();
};
template<typename USARTx, auto& tranceiver>
class USART
{
static UsartConfig config;
public:
static void Config(UsartConfig config);
static void SendByte(uint8_t byte)
{
USARTx::DR::Write(byte);
}
static uint8_t ReadByte()
{
return USARTx::DR::Get();
}
static void TransmiteEnable()
{
USARTx::CR1::TE::Enable::Set();
}
static void TransmiteBufEmptyInterruptEnable()
{
USARTx::CR1::TXEIE::InterruptWhenTXE::Set();
}  
static void TransmiteDisable()
{
USARTx::CR1::TE::Disable::Set();
}
static void TransmiteBufEmptyInterruptDisable()
{
USARTx::CR1::TXEIE::InterruptInhibited::Set();
} 
static void ReceiveEnable()
{
USARTx::CR1::RE::Enable::Set();
}
static void ReceiveDisable()
{
USARTx::CR1::RE::Disable::Set();
}
static void EndOfTransmittingEnable()
{
USARTx::CR1::IDLEIE::Interrupt::Set();
}
static void EndOfTransmittingDisable()
{
USARTx::CR1::IDLEIE::InterruptInhibited::Set();
}
static bool TransmitionCompleted()
{
return USARTx::SR::TC::TransmitionComplete::IsSet();
}
static void UsartInterruptHandler()
{
if(USARTx::SR::RXNE::DataRecieved::IsSet())
{
tranceiver.OnNextByteReceive();
}
if(USARTx::CR1::TE::Enable::IsSet()&&USART2::SR::TXE::DataRegisterEmpty::IsSet())
{
tranceiver.OnNextByteTransmite();
}
if(USARTx::CR1::IDLEIE::Interrupt::IsSet()&&USARTx::SR::IDLE::EndOfTransmitting::IsSet())
{
tranceiver.OnEndOfTransmitting();
}
}
};

==== usartconfig.h

[source, cpp]
#pragma once
#include "usartDriver.h"
#include "usart.h"
class usart2;
inline usartDriver<usart2> bluetoothTransceiver;
class usart2 : public  USART<USART2,bluetoothTransceiver> {};


==== usarDriver.h

[source, cpp]
#pragma once
#include "usart.h"
template<typename usart>
class usartDriver
{
std::array<char,1024> transmiteBuf;
std::array<char,1024> receiveBuf;
uint32_t transmiteMessLength=0;
uint32_t receiveMessLength=0;
bool messageWasReceived=false;
bool messageWasTransmited=false;
uint32_t Rit=0;
uint32_t Tit=0;
public:
void SendMessage(char* message, uint32_t size)
{
uint32_t L=size;
if(transmiteBuf.size()<L) L=transmiteBuf.size();
transmiteMessLength=L;
std::memcpy(transmiteBuf.data(), message,L);
usart::TransmiteEnable();
usart::TransmiteBufEmptyInterruptEnable();
messageWasTransmited=false;
messageWasReceived=false;
}
void OnNextByteTransmite()
{
if(Tit<transmiteMessLength-1)
{
usart::SendByte(transmiteBuf[Tit++]);
}
else
{
usart::SendByte(transmiteBuf[Tit]);
Tit=0;
while(!usart::TransmitionCompleted())
{
}
usart::TransmiteDisable();
usart::TransmiteBufEmptyInterruptDisable();
messageWasTransmited=true;
}
}
void OnNextByteReceive()
{
uint8_t bf=usart::ReadByte();
if(!messageWasReceived)
{
receiveBuf[Rit++]=bf;
usart::EndOfTransmittingEnable();
}
}
void OnEndOfTransmitting()
{
receiveMessLength=Rit;
Rit=0;
usart::EndOfTransmittingDisable();
messageWasReceived=true;
}
bool MessageWasReceived()
{
return messageWasReceived;
}
void GetMessage(char* outBuf, std::size_t& length)
{
length=receiveMessLength;
std::memcpy(outBuf, receiveBuf.data(),receiveMessLength);
messageWasReceived=false;
}
};

== Классы SPI, SpiDriver

Аналогично системе классов Usart-UsartDriver, для работы с протоколом SPI используются классы SPI, SpiDriver. 

.Диаграммы классов SPI, SpiDriver
image::kr37.png[]

*Методы SendByte() и ReadByte()* получают и передают данные в буфер.
Регистр данных разделен на 2 буфера - один для записи (буфер передачи) и другой для чтения (буфер приема). Запись в регистр данных приведет к записи в буфер Tx, а считывание из регистра данных вернет значение, хранящееся в буфере Rx.

image::sp1.png[500, 500]

*Методы TransmiteBufEmptyInterruptEnable(), TransmiteBufEmptyInterruptDisable()* отвечают за включение прерывания с пустым буфером Tx.

image::sp2.png[500, 500]

Используется для генерации запроса на прерывание, когда установлен флаг TXE.


*Методы ReceiveBufNotEmptyInterruptEnable() и ReceiveBufNotEmptyInterruptDisable()* отвечают за разрешение прерывания при заполнении буфера RX.

image::sp3.png[500, 500]


*Метод TransmittionCompleted()* отвечает за завершение передачи данных, проверяет происходит ли передача данных и пуст ли Tx буфер.

image::sp4.png[400, 400]

*Метод SpiInterruptHandler* обрабатывает прерывания буфера Rx и Tx и перенаправляет их в методы OnNextByte.


*Методы SendMessage(), SendByte()* отвечают за передачу данных по интерфейсу SPI.

*Методы  IsMessageTransmitted() и IsMessageReceived()* получают и передают  данные.

*Методы  OnNextByteTransmite() и OnNextByteReceive()* отвечают за получение и последующую передачу байтов.

*Методы GetMessage(), GetByte()* отвечают за получение данных и предоставляют доступ на их чтение.

*Метод SetReceivedMesLength* устанавливает длину полученного сообщения. 



=== Код классов SPI и SpiDriver

==== Spi.h

[source, cpp]
#pragma once
#include "spi2registers.hpp"
#include "spi1registers.hpp"
#include <gpiocregisters.hpp>
#include <gpiobregisters.hpp>

[source, cpp]
struct SpiConfig
{
  SpiConfig();
};

[source, cpp]
template<typename SPIx, auto& transceiver>
class SPI
{
  static SpiConfig config;  
  public:
  using T = char;
  static void Config(SpiConfig config);
  // получают и передают данные в буфер. Регистр данных разделен на 2 буфера - один для записи (буфер передачи) и другой для чтения (буфер приема). 
  // Запись в регистр данных приведет к записи в буфер Tx, а считывание из регистра данных вернет значение, хранящееся в буфере Rx.
  static void SendByte(T byte) 
  {   
    SPIx::DR::Write(byte);   
  }
  static T ReadByte()
  {
    return SPIx::DR::Get();
  }
  // отвечает за включение прерывания с пустым буфером Tx.
  static void TransmiteBufEmptyInterruptEnable() 
  {
    SPIx::CR2::TXEIE::NotMasked::Set();
  }  
  // отвечает за выключение прерывания.
  static void TransmiteBufEmptyInterruptDisable() 
  {
    SPIx::CR2::TXEIE::Masked::Set();
  } 
  // отвечает за включение прерывания при заполнении буфера RX.
  static void ReceiveBufNotEmptyInterruptEnable() 
  {
    SPIx::CR2::RXNEIE::NotMasked::Set();
  }  
  // отвечает за выключение прерывания.
  static void ReceiveBufNotEmptyInterruptDisable() 
  {
    SPIx::CR2::RXNEIE::Masked::Set();
  }  
  // отвечает за завершение передачи данных, проверяет происходит ли передача данных и пуст ли Tx буфер.
  static bool TransmittionCompleted() 
  {
    return SPIx::SR::BSY::NotBusy::IsSet();
  }
  // обрабатывает прерывания буфера Rx и Tx и перенаправляет их в методы OnNextByte.
  static void SpiInterruptHandler() 
  {
    if(SPIx::CR2::RXNEIE::NotMasked::IsSet()&&SPIx::SR::RXNE::RxBufferNotEmpty::IsSet())
    {
       transceiver.OnNextByteReceive();
    }
    if (SPIx::CR2::TXEIE::NotMasked::IsSet()&&SPIx::SR::TXE::TxBufferEmpty::IsSet())
    {
      transceiver.OnNextByteTransmite();
    }
  }
};

==== spiсonfig.h

[source, cpp]
#pragma once
#include "spiDriver.h"
#include "spi.h"
class spi1;
inline SpiDriver<spi1> spi1Transceiver;
class spi1 : public  SPI<SPI1, spi1Transceiver> {};


==== spiDriver.h

[source, cpp]
#pragma once
#include "spi.h"
template<typename spi>
class SpiDriver
{
  std::array<char,200> transmiteBuf = {0};
  std::array<char,200> receiveBuf = {0};
  uint32_t transmiteMessLength = 1;
  uint32_t receiveMessLength = 1;
  bool messageWasReceived = false;
  bool messageWasTransmited = false;
  uint32_t Rit=0;
  uint32_t Tit=0;
  public:
  // отвечает за передачу данных по интерфейсу SPI.
  void SendMessage(char* message, std::size_t size)
  {
    messageWasTransmited=false;   
    uint32_t L = size;
    if(transmiteBuf.size()<L) L=transmiteBuf.size();
    transmiteMessLength =L;
    std::memcpy(transmiteBuf.data(), message,transmiteMessLength);
    messageWasReceived = (receiveMessLength == 0);    
    if(receiveMessLength != 0)
    {
      spi::ReadByte();
      spi::ReceiveBufNotEmptyInterruptEnable();
    }
    spi::TransmiteBufEmptyInterruptEnable();   
  }
  void SendByte(char byte)
  {
    messageWasTransmited = false;   
    transmiteMessLength = 1;
    transmiteBuf[0] = byte;
    messageWasReceived = (receiveMessLength == 0);
    spi::ReadByte();
    if(receiveMessLength != 0)
    {
      spi::ReadByte();
      spi::ReceiveBufNotEmptyInterruptEnable();
    }
    spi::TransmiteBufEmptyInterruptEnable();   
  }
  //отвечает за передачу байтов.
  void OnNextByteTransmite()
  {
    if(Tit<transmiteMessLength||(!messageWasReceived))
    {
      if(Tit>=transmiteMessLength)
      {
        transmiteBuf[Tit]=transmiteBuf[Tit-1];
      }
      spi::SendByte(transmiteBuf[Tit++]);
    }
    else
    {
      Tit = 0;
      spi::TransmiteBufEmptyInterruptDisable();
      if(receiveMessLength == 0)
      {
        while(!spi::TransmittionCompleted())
        {
        }
      }
      messageWasTransmited = true;
    }
  }
  //отвечает за получение байтов. 
  void OnNextByteReceive()
  {
    static bool isfirst = true;
    uint8_t bf = spi::ReadByte();
    if(!messageWasReceived)
    {
      if(!isfirst)
      {
        receiveBuf[Rit++] = bf;
        if(Rit == receiveMessLength)
        {         
          spi::ReceiveBufNotEmptyInterruptDisable();
          Rit = 0;
          messageWasReceived = true;
          isfirst = true;
        }
      }
      else
      {
        isfirst = false;
      }
    }
  }
  // получает и передает данные.
  bool IsMessageReceived()
  {
    return messageWasReceived;
  }
  bool IsMessageTransmited()
  {
    return messageWasTransmited;
  }
  // отвечает за получение сообщения и предоставляет доступ на их чтение.  
  void GetMessage(char* outBuf)
  {
    std::memcpy(outBuf, receiveBuf.data(),receiveMessLength);
    //receiveBuf.fill(0);
    messageWasReceived = false;
  }
  // отвечает за получение байтов и предоставляет доступ на их чтение.  
  char GetByte()
  {
    messageWasReceived = false;
    char bf = receiveBuf[0];
    receiveBuf[0] = 0;
    return bf;
  }
  // устанавливает длину полученного сообщения.
  void SetReceivedMesLength(std::size_t size)
  {
    receiveMessLength = size;
  }
};

== Классы BluetoothUpdateTask, MeasurementTask


.Диаграммы классов BluetoothUpdateTask, MeasurementTask
image::kr38.png[]

*	BluetoothUpdateTask:  период – 1000ms, приоритет – lowest;
*	MeasurementTask:  период – 100ms, приоритет – priorityMax.



=== Код классов BluetoothUpdateTask, MeasurementTask

==== BluetoothTask.h

[source, cpp]
#pragma once
#include "thread.hpp"
#include "usartconfig.h"
#include "bme280driverconfig.h"
#include "measurementconfig.h"
#include "stdio.h"
#include "ledconfig.h"
using namespace OsWrapper;
class BluetoothTask:public Thread<400U>
{
public:
const std::chrono::milliseconds period = 1000ms;
BluetoothTask(){}
void Execute() override
{
for(;;)
{    
char transmittedMess[150]={0};
size_t lengthTransmitedMess;
for(int k=0;k<4;k++)
{
char str[100]={0};
std::sprintf(str,"%11s : %5.2f %5s \n",measurements[k]->quantityName.c_str(),
measurements[k]->GetValue(userUnits[k]),Measurement::ShowUnitName(userUnits[k]).c_str());
strncat(transmittedMess,str,100);
}
lengthTransmitedMess = std::strlen(transmittedMess);
bluetoothTransceiver.SendMessage(transmittedMess,lengthTransmitedMess);
Led1::Toggle();
Sleep(period);
}
}
};

==== MeasurementTask.h

[source, cpp]
#pragma once
#include "thread.hpp"
#include "ledconfig.h"
#include "measurementconfig.h"
#include "event.hpp";
#include "bme280driverConfig.h"
using namespace OsWrapper;
template<auto& event>
class MeasurementTask:public Thread<128U>
{
public:
const std::chrono::milliseconds period = 100ms;
void Execute() override
{
for(;;)
{ 
bme280.Measure();
Led2::Toggle();
Sleep(period);
if (event.Wait() != 0)
{
UnitsUpdate();
}
}
}
void UnitsUpdate()
{
static int counter = 0;
counter=(counter<2)?(counter+1):0;
switch(counter)
{
case 0:
userUnits[0]=Unit::F;
userUnits[3]=Unit::F;
break;
case 1:
userUnits[0]=Unit::K;
userUnits[3]=Unit::K;
break;
case 2:
userUnits[0]=Unit::C;
userUnits[3]=Unit::C;
break;
}
}
};

== Предусмотрим измерение температуры при нажатии кнопки
По нажатию кнопки USER на плате единцы измерения температуры будут изменяться в следующей последовательности F (Фаренгейт)→K (Кельвин)→C (Цельсий).
Для работы с кнопкой предусмотрим класс Button. При нажатии кнопки задача будет генерировать событие, меняющей единицы измерения температурных величин.

Для работы с кнопкой предусмотрим класс Button. Для обработки нажатий кнопки предусмотрим задачу ButtonPressTask c малым периодом (100 ms). При нажатии кнопки задача будет генерировать событие, которое будет отслеживаться задачей MeasureTask, циклично меняющей единицы измерения температурных величин.

.Обновлённая диаграмма
image::kr39.png[]

=== Класс Temperature

Реализуюет логику пересчета из одной температурной шкалы в другую, используется для описания величин, имеющих размерность температуры: temperature и dewPoint. Давление и влажность в рамках данной программы имеют по одной единице измерения, и ввиду отсутствия специальной логики для их описания достаточно базового класса.
На рисунке приведены диаграммы классов Measurement и Temperature, а также экземпляры этих классов temperature, pressure, humidity, dewPoint, указатели на которые объединены в массив measurements.

image::kr40.png[]

==== Код Temperature и обновлённый код MEASUREMENT

measurement.h

[source, cpp]
#include <string>
#include <cassert>
#pragma once
enum class Unit
{
K,
F,
C,
hPa,
percent
};
class Measurement
{
protected:
double(*DataSourceFcn)();
public:  
const Unit *const units;
const std::size_t countOfUnits;
const Unit defaultUnit;
std::string quantityName;
Measurement(std::string quantityName, Unit* units, std::size_t countOfUnits, Unit defaultUnit, double(*DataSourceFcn)()):
quantityName(quantityName),units(units), countOfUnits(countOfUnits),defaultUnit(defaultUnit), DataSourceFcn(DataSourceFcn)
{
assert(CheckUnit(defaultUnit) &&" defalt unit must match measurement's units");
}
Measurement(std::string quantityName, Unit unit, double(*DataSourceFcn)()):
quantityName(quantityName),defaultUnit(unit),units(&defaultUnit), countOfUnits(1), DataSourceFcn(DataSourceFcn)
{
}
virtual double GetValue()
{
return DataSourceFcn();
}
virtual double GetValue(Unit unit)
{
assert(CheckUnit(unit)&&" defalt unit must match measurement's units");
return DataSourceFcn();
}
bool CheckUnit(Unit unit)
{
bool flag=false;
for(int i=0;i<countOfUnits;i++)
{
if(unit==units[i])
{
flag=true;
}
}
return flag;
}
static string ShowUnitName(Unit unit)
{
string str;
switch(unit)
{  
case Unit::K:
str = "K";
break;
case Unit::F:
str = "F";
break;
case Unit::C:
str = "C";
break;
case Unit::hPa:
str = "hPa";
break;
case Unit::percent:
str = "%";
break;  
default:
assert(false &&" unit must match measurement's units");
break;
}
return str;
}
};

Temperature.h

[source, cpp]
pragma once
#include "Measurement.h"
#include <cassert>
Unit temperatureUnits[3]={Unit::K,Unit::C,Unit::F};
class Temperature: public Measurement
{
public:
Temperature(string quantityName, double(*DataSourceFcn)())
:Measurement(quantityName, temperatureUnits, 3, Unit::C, DataSourceFcn){}
virtual double GetValue()
{
return DataSourceFcn();
}
virtual double GetValue(Unit unit)
{
double value;
switch(unit)
{
case Unit::C:
value = Measurement::GetValue();
break;
case Unit::K:
value = GetValue()+273.15;
break;
case Unit::F:
value = GetValue()*1.8+32.0;
break;
default:
assert(false &&"unit must match measurement's units");
break;
}
return value;
}
};


=== Классы Port, Pin, Button

.Диаграммы классов Port, Pin и Button
image::kr41.png[]

==== Код Port, Pin, Button

*Pin.h*

[source, cpp]
#pragma once
#include <cstdint> // for uint8_t
#include "port.h" 
template<typename Port, uint8_t number>
class Pin
{  
public: 
static void Toggle()
{
Port::Toggle(number);
}
static void Set()
{
Port::Set(1<<number);
}
static void Reset()
{
Port::Reset(1<<number);
}
static bool IsSet()
{
return Port::IsSet(number);
}
static uint8_t Get()
{
return IsSet()?1U:0U;
}
static void Enable()
{
if(!Port::IsEnable())Port::Enable();
}
static void SelectInputMode()
{
Port::ModeSet(number,Moder::Input);
}
static void SelectOutputMode()
{
Port::ModeSet(number,Moder::Output);
}
static void SelectMode(Moder moder)
{
Port::ModeSet(number,moder);
}
};


*PinConfig.h*

[source, cpp]
#pragma once
#include "pin.h"         // for Pin
#include "portsconfig.h" // for PortC, PortA
using PinLed1 = Pin<PortA, 5>;
using PinLed2 = Pin<PortC, 9>;
using PinLed3 = Pin<PortC, 8>;
using PinLed4 = Pin<PortC, 5>;
using PinButton = Pin<PortC, 13>;
using PinCSforBME280 = Pin<PortB, 10>;
using PinCSforEPD = Pin<PortB, 1>;
using PinDCforEPD = Pin<PortB, 2>;
using PinRSTforEPD = Pin<PortC, 3>;
using PinBSYforEPD = Pin<PortC, 2>;

*Port.h*

[source, cpp]
#pragma once
#include <cstdint> // for uint8_t
#include "gpiocregisters.hpp" // for GPIOC
#include "gpioaregisters.hpp" // for GPIOC
#include "gpiocregisters.hpp" 
#include "gpiobregisters.hpp" 
#include "rccregisters.hpp" 
enum Moder
{
Input=0,
Output=1,
Alternate=2,
Analog=3,
}; 
template<typename PortType>
struct AHB1ENR_of
{
};
template<>
struct AHB1ENR_of<GPIOC>
{
using Enable = RCC::AHB1ENR::GPIOCEN::Enable;
using Disable = RCC::AHB1ENR::GPIOCEN::Disable;
};
template<>
struct AHB1ENR_of<GPIOA>
{
using Enable = RCC::AHB1ENR::GPIOAEN::Enable;
using Disable = RCC::AHB1ENR::GPIOAEN::Disable;
};
template<>
struct AHB1ENR_of<GPIOB>
{
using Enable = RCC::AHB1ENR::GPIOBEN::Enable;
using Disable = RCC::AHB1ENR::GPIOBEN::Disable;
};
template<typename Reg>
class Port
{
public:  
static void Toggle(uint8_t num) 
{
Reg::ODR::Toggle(1U << num);
}
static bool IsSet(uint8_t num)
{
return (Reg::IDR::Get()&(1<<num))!=0;
}
static uint32_t Get()
{
return Reg::IDR::Get();
}
static void Write(uint32_t value)
{
Reg::ODR::Write(value);
}
static void Set(uint32_t value) 
{
Reg::BSRR::Write(value);
}
static void Reset(uint32_t value) 
{
Reg::BSRR::Write(value<<16);
}
static void ModeSet(uint8_t num, Moder moder) 
{
auto value = Reg::MODER::Get();
value &= ~(3U<<(num*2U));
value |= moder<<(num*2U);
Reg::MODER::Write(value);
}
static void Enable() 
{
AHB1ENR_of<Reg>::Enable::Set();
}
static void Disable() 
{
AHB1ENR_of<Reg>::Disable::Set();
}
static bool IsEnable() 
{
return AHB1ENR_of<Reg>::Enable::IsSet();
}
};

*PortConfig.h*

[source, cpp]
#pragma once
using PortA = Port<GPIOA>;
using PortB = Port<GPIOB>;
using PortC = Port<GPIOC>;

*Button.h*

[source, cpp]
#pragma once
#include "pin.h"
#include "pinsconfig.h"
template<typename Pin>
class Button
{
public:
static bool WasPressed()
{
if(!Pin::IsSet())
{
while(!Pin::IsSet());
return true;
}
return false;
}
static void Enable()
{
Pin::Enable();
Pin::SelectInputMode();
}
};
using UserButton = Button<PinButton>;


=== Класс ButtonPressTask

.Диаграмма класса ButtonPressTask
image::kr42.png[]

*	ButtonPressTask:  период – 100ms, приоритет – highest;

==== Код

*ButtonEventTask.h*

[source, cpp]
#pragma once
#include "thread.hpp"
#include "Button.h"
#include "event.hpp"
using namespace OsWrapper;
template<typename Button, auto& event>
class ButtonEventTask:public Thread<128U>
{
public:
ButtonEventTask()
{
Button::Enable(); 
}
void Execute()
{
for(;;)
{
if (Button::WasPressed())
{
event.Signal();
}
Sleep(100ms);
}
}
};

== Main.cpp

[source, cpp]
#include "rtos.hpp"         // for Rtos
#include "event.hpp"        // for Event
#include "ledconfig.h"
#include "Button.h"
#include "BluetoothTask.h"
#include "ButtonEventTask.h"
#include "MeasurementTask.h"
#include "rccregisters.hpp" // for RCC
#include "Application/Diagnostic/GlobalStatus.hpp"
#include <gpioaregisters.hpp>  // for GPIOA
#include <gpiobregisters.hpp>  // for GPIOB
#include <gpiocregisters.hpp>  // for GPIOC
#include "Measurementconfig.h"
std::uint32_t SystemCoreClock = 16'000'000U;
#include "stdio.h"
#include <iostream>
#include "usart2registers.hpp"
#include "nvicregisters.hpp"
#include "spi1registers.hpp"
#include "Math.h"
#include <iostream>
extern "C" {
int __low_level_init(void)
{
//Switch on external 16 MHz oscillator
RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{
}
//Switch system clock on external oscillator
RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
{
}
RCC::AHB1ENR::GPIOAEN::Enable::Set();
//USART config
RCC::APB1ENR::USART2EN::Enable::Set();
GPIOA::MODER::MODER3::Alternate::Set();
GPIOA::MODER::MODER2::Alternate::Set();
GPIOA::AFRL::AFRL3::Af7::Set();
GPIOA::AFRL::AFRL2::Af7::Set();
GPIOA::PUPDR::PUPDR2::NoPullUpNoPullDown::Set();
GPIOA::PUPDR::PUPDR3::PullUp::Set();
USART2::CR1::OVER8::OversamplingBy16::Set();
USART2::CR1::M::Data8bits::Set();
USART2::CR2::STOP::OneStopBit::Set();
USART2::CR1::PCE::ParityControlDisable::Set();
USART2::CR1::RE::Enable::Set();
NVIC::ISER1::Write(1<<6);
USART2::CR1::RXNEIE::InterruptWhenRXNE::Set();
constexpr uint32_t CLC = 16'000'000U;
constexpr uint32_t BaudRate=9600;
double UsartDivDouble = 1.0/(BaudRate*8*(2 - USART2::CR1::OVER8::Get()))*CLC;
uint32_t UsartDivMantissa=UsartDivDouble;
uint16_t UsartDivFraction=round((UsartDivDouble-UsartDivMantissa)*16);
USART2::BRR::DIV_Mantissa::Set(UsartDivMantissa);
USART2::BRR::DIV_Fraction::Set(UsartDivFraction);
RCC::AHB1ENRPack<
RCC::AHB1ENR::GPIOCEN::Enable,
RCC::AHB1ENR::GPIOBEN::Enable,
RCC::AHB1ENR::GPIOAEN::Enable
>::Set();
//SPI1 config
RCC::APB2ENR::SPI1EN::Enable::Set();
NVIC::ISER1::Write(1<<3);
SPI1::CR1::MSTR::Master::Set();
SPI1::CR1::DFF::Data8bit::Set();
SPI1::CR1::BR::PclockDiv2::Set();
SPI1::CR1::CRCEN::CrcCalcDisable::Set();
SPI1::CR1::CPOL::High::Set();
SPI1::CR1::CPHA::Phase2edge::Set();
SPI1::CR1::LSBFIRST::MsbFisrt::Set();
SPI1::CR2::SSOE::SsOutputEnable::Set(); 
SPI1::CR1::SSM::NssSoftwareEnable::Set();
SPI1::CR1::SSI::Value1::Set();
GPIOB::MODERPack<
GPIOB::MODER::MODER3::Alternate, //sck
GPIOB::MODER::MODER4::Alternate, //miso
GPIOB::MODER::MODER5::Alternate, //mosi
GPIOB::MODER::MODER10::Output,   //cs for bme280
>::Set();
GPIOB::AFRLPack<
GPIOB::AFRL::AFRL3::Af5,
GPIOB::AFRL::AFRL4::Af5,
GPIOB::AFRL::AFRL5::Af5,
>::Set();  
GPIOB::BSRR::BS10::High::Write() ;
return 1;
}
}
OsWrapper::Event event(100ms, 1);
ButtonEventTask<UserButton, event> buttonEventTask;
BluetoothTask bluetoothTask;
MeasurementTask<event> measurementTask;
int main()
{  
USART2::CR1::UE::Enable::Set();    
SPI1::CR1::SPE::Enable::Set();
bme280.InitializeCalibrateData();
bme280.StartMeasurements();
using namespace OsWrapper;
Rtos::CreateThread(bluetoothTask,"bluetoothTask", ThreadPriority::lowest);
Rtos::CreateThread(buttonEventTask,"buttonEventTask", ThreadPriority::highest);
Rtos::CreateThread(measurementTask,"measurementTask", ThreadPriority::priorityMax);
Rtos::Start();
return 0;
}

= Результат программы

Демонстрация работы Bluetooth-модуля

 
image::kr43.png[700, 700]

image::kr44.png[700, 700]

= Заключение

В ходе работы над курсовым проектом было разработано программное обеспечение для метеостанции на базе датчика BME280. Вывод результатов измерения производится на смартфон по протоколу Bluetooth.
