:imagesdir: Images
:figure-caption: Рисунок
:table-caption: Таблица
= Курсовой проект
:toc:
:toc-title: Оглавление:

Тема работы: *Разработка метеостанции с передачей параметров по беспроводному интерфейсу*

Чепульская О.С., Яковенко А.Д. КЭ-413 +

= Задание на курсовой проект 

Для разработки должна использоваться отладочная плата  *XNUCLEO-F411RE*. +

Питание платы должно быть автономным и подаваться с солнечный батарей. +

Программное обеспечение измерение должно измерять давление, влажность и температуру и рассчитывать точку росы:

* Период измерения должен быть 100 ms.
* Для измерения давления, влажности и температуры должен использоваться датчик *BME280*
* Общение с датчиком должно осуществляться по интерфейсу SPIx (где х - любой не равный 1,2,3)
* Точка росы должна считаться на основе текущих показаний влажности и давления

Передача значений по беспроводному интерфейсу должна осуществляться через модуль BlueTooth Bee *HC-06*

* Формат вывода: +
"Давление:" XXX.XX +
"Влажность:" XXX.XX +
"Температура:" XXX.XX +
"Точка росы":" XXX.XX +

* Для подключения модуля BlueTooth должна использоваться плата *Accessories* *Shield* или I/O Expansion Shield
* Общение с платной модуля BlueTooth должна осуществляться через USART2
* Период вывода информации через BlueTooth модуль должен быть 1 секунда.

Архитектура должна быть представлена в виде UML диаграмм в пакете Star UML.

Приложение должно быть написано на языке С++ с использование компилятора ARM 9.10

При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и С++ обертка над ней.


= Анализ требований к разработке


== Для разработки должна использоваться отладочная плата XNUCLEO-F411RE

XNUCLEO-F411RE – это отладочная плата от компании Waveshare с поддержкой Arduino, которая позволит изучить возможности микроконтроллера STM32F411RET6 на базе ядра Cortex-M3.

.Вид платы XNUCLEO-F411RE.
image::kr1.png[300, 300]


== Питание платы должно быть автономным и подаваться с солнечный батарей

Питание будет подаваться с модуля управления солнечной энергией, для панели солнечных батарей 6V~24V. 
Этот модуль управления солнечной энергией может заряжать аккумуляторную литиевую батарею 3.7 V через солнечную панель или USB-соединение и обеспечивает регулируемый выход 5V/1A.

Характеристики:

* Напряжение солнечной панели (SOLAR IN): 6V ~ 24V;
* Зарядные устройства: Солнечная панель, адаптер питания, USB;
* USB-интерфейс зарядки: Micro USB: 5V/1A;
* Внутренняя литий-батарея: 3.7 V 14500 Li-battery;
* Входное напряжение USB: 5V (интерфейс Micro USB);
* Выход 5V: 5V / 1A (USB OUT, GPIO);
* Защита от напряжения отключения заряда: 4.2 V ± 1％;
* Напряжение защиты от перегрузки: 2.9V ± 1％;
* Эффективность заряда солнечной панели: 78%;
* Эффективность зарядки USB: 82%;
* Максимальный ток покоя: <2мА;
* Рабочая температура: -40℃ ~ 85℃.

.Модуль управления солнечной энергией
image::kr2.png[250, 250]

.Способ подключения солнечной батареи
image::kr3.png[500, 500]

== Программное обеспечение измерение должно измерять давление, влажность и температуру и рассчитывать точку росы.


*Период измерения должен быть 100 ms.*

=== Для измерения давления, влажности и температуры должен использоваться датчик BME280

*BME280* – высокоточный метеодатчик, измеряющий такие параметры микроклимата как температура, влажность и атмосферное давление. +
В зависимости от модуля может подключаться к I2C и SPI шинами микроконтроллера и работать от 3-5V, если на плате есть стабилизатор, или 3V, если его нет. +
Данный модуль работает по двухпроводному интерфейсу I2C, адрес по умолчанию 0x76, но есть возможность изменить на адрес 0x77. Модуль подключается на шину I2C и питание, как и любой другой модуль такого типа. +

Примеры библиотек для работы с датчиком:

* Adafruit BME280 (для работы также нужна Adafruit Sensor) – самая известная библиотека для работы с BME280. Часть настроек доступна только при ручном редактировании библиотеки.
* GyverBME280 –Также поддерживает датчики BMP280

Благодаря сверхмалому форм-фактору, низкому энергопотреблению, высокой точности и стабильности датчик окружающей среды BME280 подходит для таких применений, как мониторинг окружающей среды, прогноз погоды.

*Управление питанием*. BME280 имеет два отдельных вывода источника питания:

* Vdd является основным источником питания для всех внутренних аналоговых и цифровых функциональных блоков;
* Vddio - это отдельный вывод источника питания, используемый для питания цифрового интерфейса.

Встроенный генератор сброса питания (POR), он сбрасывает логическую часть и значения регистра после обоих Vdd и Vddio достигают своих минимальных уровней. Нет никаких ограничений на наклон и последовательность повышения уровней Vdd и Vddio.

*Режимы датчика*. BME280 предлагает три режима работы датчика: 

* Sleep mode: не работает, доступны все регистры, самая низкая мощность, выбирается после запуска;
* Forced mode: выполнит одно измерение, сохранит результаты и вернется в спящий режим;
* Normal mode: непрерывный цикл измерений и периоды бездействия.



=== Общение с датчиком должно осуществляться по интерфейсу SPIx (где х - любой не равный 1,2,3)

Последовательный периферийный интерфейс (SPI) обеспечивает полудуплексную/полнодуплексную синхронную последовательную связь с внешними устройствами. Интерфейс может быть сконфигурирован как ведущий, и в этом случае он обеспечивает синхронизацию связи (SCK) с внешним подчиненным устройством. + 
Интерфейс также способен работать в конфигурации multimaster. Он может использоваться для различных целей, включая симплексную синхронную передачу по двум линиям с возможной двунаправленной линией передачи данных или надежную связь с использованием проверки CRC. +
Интерфейс SPI имеет два режима: 4-проводной и 3-проводной. Протокол одинаков для обоих.




Интерфейс SPI:

|===
|Function pin | STM32 interface | Describe

| VCC		
| 3.3V /5V
| Входная мощность 3.3V

| GND		
| GND
| Земля

| MOSI
| PB5		
| SPI data input

| SCK
| PB3		
| SPI clock input


| MISO
| PB4		
| SPI data output

| CS	
| PB10
| Выбор чипа SPI, активный при низком напряжении

|===



Обычно SPI подключается к внешним устройствам через четыре контакта:

* MISO: Master In / Slave Out data. 
* MOSI: Master Out / Slave In data. 
* SCK: Serial Clock output for SPI masters and input for SPI slaves. (Последовательный тактовый выход для ведущих SPI и вход для ведомых SPI.)
* NSS: Slave select. This is an optional pin to select a slave device. (Выбор ведомого устройства, позволяя ведущему SPI взаимодействовать с подчиненными устройствами индивидуально и избегать конфликтов в линиях передачи данных.)


image::kr12.png[600, 600]

.Структурная схема SPI
image::kr11.png[]


Контакты MOSI и контакты MISO соединены вместе. Таким образом, данные передаются последовательно между ведущим и ведомым (сначала самый значимый бит).

Общение всегда инициируется мастером. Когда ведущее устройство передает данные на подчиненное устройство через вывод MOSI, подчиненное устройство отвечает через вывод MISO. Это подразумевает полнодуплексную связь как с выводом данных, так и с вводом данных, синхронизированных с одним и тем же тактовым сигналом (который обеспечивается главным устройством через вывод SCK).

*Методы SendByte() и ReadByte()* получают и передают данные в буфер.
Регистр данных разделен на 2 буфера - один для записи (буфер передачи) и другой для чтения (буфер приема). Запись в регистр данных приведет к записи в буфер Tx, а считывание из регистра данных вернет значение, хранящееся в буфере Rx.

image::sp1.png[500, 500]

*Методы TransmiteBufEmptyInterruptEnable(), TransmiteBufEmptyInterruptDisable()* отвечают за включение прерывания с пустым буфером Tx.

image::sp2.png[500, 500]

Используется для генерации запроса на прерывание, когда установлен флаг TXE.


*Методы ReceiveBufNotEmptyInterruptEnable() и ReceiveBufNotEmptyInterruptDisable()* отвечают за разрешение прерывания при заполнении буфера RX.

image::sp3.png[500, 500]


*Метод TransmittionCompleted()* отвечает за завершение передачи данных, проверяет происходит ли передача данных и пуст ли Tx буфер.

image::sp4.png[400, 400]

*Метод SpiInterruptHandler* обрабатывает прерывания буфера Rx и Tx и перенаправляет их в методы OnNextByte.


*Методы SendMessage(), SendByte()* отвечают за передачу данных по интерфейсу SPI.

*Методы  IsMessageTransmitted() и IsMessageReceived()* получают и передают  данные.

*Методы  OnNextByteTransmite() и OnNextByteReceive()* отвечают за получение и последующую передачу байтов.

*Методы GetMessage(), GetByte()* отвечают за получение данных и предоставляют доступ на их чтение.

*Метод SetReceivedMesLength* устанавливает длину полученного сообщения. 


Для примера приведём часть инициализации использования SPI для датчика BME280, с использованием библиотеки предоставленной Bosch Sensortec:

[source, cpp]
struct bme280_dev dev;
int8_t rslt = BME280_OK;
/* Sensor_0 interface over SPI with native chip select line */
dev.dev_id = 0;
dev.intf = BME280_SPI_INTF;
dev.read = user_spi_read;
dev.write = user_spi_write;
dev.delay_ms = user_delay_ms;
rslt = bme280_init(&dev);


Среди них bme280_dev - это структура устройства BME280, приведенная в официальной библиотеке. Он используется для инициализации и сбора данных. Реализует следующие функции:

[source, cpp]
user_spi_read()
user_spi_write()
user_delay_ms()


Функция считывания данных BME280:

[source, cpp]
int8_t stream_sensor_data_forced_mode(struct bme280_dev *dev)
int8_t stream_sensor_data_normal_mode(struct bme280_dev *dev)


все вышеперечисленные функции вызывают функцию вывода:

[source, cpp]
void print_sensor_data(struct bme280_data *comp_data)


Идеи реализации функций, чтения SPI, записи SPI заключаются в следующем:


[source, cpp]
void user_delay_ms(uint32_t period)
{
    /*
     * Return control or wait,
     * for a period amount of milliseconds
     */
}
int8_t user_spi_read(uint8_t dev_id, uint8_t reg_addr, uint8_t *reg_data, uint16_t len)
{
    int8_t rslt = 0; /* Return 0 for Success, non-zero for failure */
    /*
     * The parameter dev_id can be used as a variable to select which Chip Select pin has
     * to be set low to activate the relevant device on the SPI bus
     */
    /*
     * Data on the bus should be like
     * |----------------+---------------------+-------------|
     * | MOSI           | MISO                | Chip Select |
     * |----------------+---------------------|-------------|
     * | (don't care)   | (don't care)        | HIGH        |
     * | (reg_addr)     | (don't care)        | LOW         |
     * | (don't care)   | (reg_data[0])       | LOW         |
     * | (....)         | (....)              | LOW         |
     * | (don't care)   | (reg_data[len - 1]) | LOW         |
     * | (don't care)   | (don't care)        | HIGH        |
     * |----------------+---------------------|-------------|
     */
    return rslt;
}
int8_t user_spi_write(uint8_t dev_id, uint8_t reg_addr, uint8_t *reg_data, uint16_t len)
{
    int8_t rslt = 0; /* Return 0 for Success, non-zero for failure */
    /*
     * The parameter dev_id can be used as a variable to select which Chip Select pin has
     * to be set low to activate the relevant device on the SPI bus
     */
    /*
     * Data on the bus should be like
     * |---------------------+--------------+-------------|
     * | MOSI                | MISO         | Chip Select |
     * |---------------------+--------------|-------------|
     * | (don't care)        | (don't care) | HIGH        |
     * | (reg_addr)          | (don't care) | LOW         |
     * | (reg_data[0])       | (don't care) | LOW         |
     * | (....)              | (....)       | LOW         |
     * | (reg_data[len - 1]) | (don't care) | LOW         |
     * | (don't care)        | (don't care) | HIGH        |
     * |---------------------+--------------|-------------|
     */
    return rslt;
}

Подводя итог, на основе официальной библиотеки, основной процесс получения данных BME280 для различных платформ выглядит следующим образом: + 
*Шаг 1:* Инициализация системы и периферийных устройств. +
*Шаг 2:* Реализуйте функции чтения SPI, записи SPI, задержки на разных платформах, назначьте указатель функции переменной-члену структуры bme280_dev и передайте указатель структуры для инициализации и после этого можно инициализировать устройство BME280. +
*Шаг 3:* Вызов функции int8_t stream_sensor_data_forced_mode(struct bme280_dev *dev) или функции int8_t stream_sensor_data_normal_mode(struct bme280_dev *dev), получая данные датчика BME280 и выводит их на главный компьютер или консоль. +






=== Точка росы должна считаться на основе текущих показаний влажности и давления

В данном курсовом проекте необходимо рассчитать и вывести точку росы.

Температура точки росы газа (точка росы) — значение температуры газа, при которой водяной пар, содержащийся в газе, охлаждаемом изобарически, становится насыщенным над плоской поверхностью воды.

Точка росы – это температура воздуха, при которой содержащийся в нём пар достигает состояния насыщения и начинает конденсироваться в росу.

*Точка росы бывает двух видов*: точка росы под давлением и атмосферная точка росы.

*1. Точка росы под давлением [°Cтрд]*

Точка росы под давлением [°Cтрд] - это температура, до которой сжатый воздух может быть охлажден без образования конденсата. Точка росы зависит от давления процесса. Когда давление падает, точка росы также снижается.

Говоря о системах под давлением, мы имеем в виду точку росы под давлением, но не атмосферную точку росы. Описание различий между этими двумя физическими параметрами приводится ниже.

*2. Атмосферная точка росы [°CtdA]*

Атмосферная точка росы [°CтрА] – температура, до которой атмосферный воздух (воздух под давлением приблиз. 1 бар абс.) может быть охлажден без образования конденсата.
В требованиях не сказано какая точка росы необходима.

При анализе точки росы под давлением было выяснено, что данная точка расчитывается путем диаграмм Молье. +
Традиционные психрометрические диаграммы верны только при одном уровне давления, обычно при атмосферном давлении (применение в области технологий кондиционирования воздуха, см. “Стационарные технологии для измерения влажности, дифференциального давления и температуры”). +
Психрометрическая диаграмма ниже показывает соотношение разных переменных влажности (точка росы [°Cтр],относительная влажность [%ОВ] и степень влажности [г/кг] также, как и температура [°C] ) в том числе при неатмосферном давлении. +

.Диаграмма Молье
image::kr5.png[500, 500]


Так как данное преобразование занимает больше времени, чем отводится на реализацию проекта, было установлено, что расчет будет проводится только атмосферной точки росы. +
Формула для приблизительного расчёта точки росы в градусах Цельсия (только для положительных температур):

image::kr6.png[]

где: +
a = 17,27, +
b= 237,7 °C, +

image::kr8.png[170, 170]

Т - температура в градусах Цельсия, +
RH - относительная влажность в объёмных долях (0 < RH < 1,0). +

Формула обладает погрешностью ±0,4 °C в следующем диапазоне значений:

0 °C <T < 60 °C +
0,01 < RH < 1,00 +
0 °C < T, < 50 °C +


Существует более простая формула для приблизительного расчёта, дающая погрешность ±1,0 °C при относительной влажности в объёмных долях более 0,5. +
Эту формулу можно использовать для вычисления относительной влажности по известной точке росы. +
При анализе выяснено, что расчет идет а.т.р. так как диаграммы молье сложны для реализации в короткие сроки, потому что необходима интерполяция и аппроксимация функций, а также из-за отсутствия условий на диапазон используемого давления, мы не можем определить нужные нам функции для работы с точкой росы под давлением. +
 

== Передача значений по беспроводному интерфейсу должна осуществляться через модуль BlueTooth Bee HC-06

Беспроводной модуль для приема/передачи данных в Arduino проектах по протоколу Bluetooth.

Особенности:

* Поддерживает работу с любым USB Bluetooth адаптером;
* Скорость передачи данных: 9600 бит/сек;
* Встроенная антенна;
* Радиус действия до 10 метров.
* Питание 3,3В – 6 В;
* Скорость передачи данных 1200–1382400 бод;
* Рабочие частоты 2,40 ГГц – 2,48ГГц;


Модуль HC-06 используется только в режиме slave, то есть он не может самостоятельно подключаться к другим устройствам Bluetooth. Все настройки для подключения «пароль, скорость передачи данных» можно изменить при помощи АТ-команд.


Основная функция модуля Bluetooth - это организация связи по последовательному интерфейсу там, где ранее для связи применялась кабельная линия.

Основные заводские параметры HC-06:

* *Режим ведущего:* имеет встроенную память, для запоминания последнего связанного ведомого устройства. Устанавливает связь только если на контакт (PIN26) подан низкий уровень. По умолчанию на PIN26 установлен низкий уровень.
* *Установка связи:* ведущее устройство осуществляет поиск и соединение с ведомым автоматически.
* *Основной метод:* при выполнении некоторых условий, ведущее и ведомые устройства соединяются автоматически.
* *AT режим:* До установления связи устройство работает в режиме AT. После установления связи с другим устройством идёт прямая передача информации.
* Во время установления связи модуль не может входить в режим AT.
* *Скорость* по умолчанию — 9600.
* Светодиод LED: Период мигания ведомого устройства — 102мс. Если ведущее устройство уже есть в памяти ведомого, то период становится 110мс. Если ведущего устройства в памяти нет, то период моргания 750мс. После установления связи и на ведущем, и на ведомом устройствах контакт светодиода переходит на высокий уровень.
* Энергопотребление: Во времяустановления связи значение тока изменяется от 30 до 40 мА. Среднее значение составляет 25мА. После установления связи, есть ли передача или нет, ток составляет 8мА.
* Сброс: PIN11, низкий уровень активный.


.Модуль BlueTooth Bee HC-06
image::kr23.png[300, 300]



Модуль имеет следующие контакты:

|===
|PIN | Описание
|PIN1 | Передача UART_TXD , уровень ТТЛ/КМОП, вывод данных UART

|PIN2 | Прием UART_RXD, уровень ТТЛ/КМОП, ввод данных UART

|PIN11 | Сброс модуля. Подача низкого уровня на контакт приведёт к сбросу.

|PIN12 | VCC, напряжение питания. Стандартный уровень напряжения составляет 3,3В, диапазон возможных значений 3,0-4,2В

|PIN13 | GND, заземление
|PIN22 | GND, заземление
|PIN24 | LED, Светодиод, индикатор рабочего режима.
|PIN26 | В случае ведущего устройства контакт обнуляет информацию о запоминаемых устройствах. После обнуления ведущее устройство будет искать ведомое случайным образом. Адрес нового устройства будет записан в память, и в следующий раз в поиске будет только оно.
|===

Для работы HC-06 требует подключения только контактов: UART_TXD, UART_RXD,VCC и GND. +
Однако, рекомендуется подключать также LED и KEY (при использовании в качестве ведущего). +
Передатчик 3,3В TXD платы микроконтроллера соединяется с приемником UART_RXD модуля HC-06, приемник 3,3В RXD платы соединяется с передатчиком UART_TXD модуля HC-06, питание 3,3В и заземление GND. Это — самая простая схема подключения.

*Первое установление связи* У ведущего устройства HC-06 до первого включения память пуста. Если введен верный
пароль, то ведущее устройство автоматически установит связь с ведомым устройством при
первом запуске. Для последующих запусков ведущее устройство запомнит адрес Bluetooth
последнего ведомого и будет осуществлять его поиск. Поиск не заканчивается, пока устройство не
будет найдено. Если на PIN26 ведущего устройства подан высокий уровень, то память будет
очищена. В этом случае, как и при первом запуске, устройство начнёт поиск. Благодаря этой
функции ведущее устройство может устанавливать связь с устройством, имеющим определенный
адрес.


=== Формат вывода:

"Давление: " XXX.XX  +
"Влажность: " XXX.XX  +
"Температура: " XXX.XX  +
"Точка росы": " XXX.XX  +

=== Для подключения модуля BlueTooth должна использоваться плата Accessories Shield или I/O Expansion Shield

В нашем проекте, мы будем использовать плату расширения *Accessory* *Shield*

Accessory Shield - это плата расширения совместимая с популярными платформами для разработки электронных приложений, такими как Arduino UNO, Arduino Leonardo, NUCLEO, XNUCLEO и совместимыми. +
Особенности:

* Разъем расширения для подключения плат Arduino;
* Разъем XBee для подключения беспроводных модулей;
* Индикатор состояния XBee;
* Индикатор питания;
* Кнопка сброса модулей XBee и Arduino;

Компиляция и загрузка программы:

1) Включите загрузочный режим платы разработки UNO PLUS и установите VCC на 5 В; +
2) Подключите дополнительный модуль Shield к плате разработки UNO PLUS, а затем
плату разработки к вашему ПК с помощью USB-кабеля. Вы можете видеть, что индикатор питания на
модуле загорается, когда модуль работает правильно. +
3) В этом документе представлен метод компиляции и загрузки программы с помощью демо
-версии, предоставленной Arduino IDE. Нажмите Файл -> Пример -> 01.Основы -> Мигнуть, чтобы открыть демонстрацию. +


Интерфейс XBee: XBee от MaxStream - это модуль беспроводной связи, основанный на технологии ZigBee. Благодаря
простому в использовании дизайну он может автоматически передавать введенные данные на другой модуль XBee по
беспроводному соединению. И он также поддерживает AT-команды для предварительной настройки. +
Установите Дополнительные защитные перемычки: +
 Подключите TXD к TX; +
 Подключите RXD к RX. +

Заводские настройки модуля XBee по умолчанию следующие: 

* Скорость передачи данных в бодах: 9600;
* Data Bits: 8;
* Flow Control: NONE;
* Parity: NONE;
* Stop Bits: 1.

.Плата Accessories Shield
image::kr9.png[400, 400]


=== Общение с платной модуля BlueTooth должна осуществляться через USART2

Режим встроенного загрузчика используется для программирования флэш-памяти с использованием интерфейса: USART2 (PD5/PD6) +
В модуле USART можно настраивать следующие параметры:

*	Скорость обмена до 4 мбит/c
*	Контроль четности
*	1 или 2 стоповых битов
*	8 или 9 бит данных
*	Запросы на детектирование ошибок приемо-передачи
*	Прерывания по приему, передачи, ошибкам передачи

Для настройки и работы модуля UART нужны всего несколько регистров 

*	USART_CR1/CR2/CR3 - регистр настройки 1
*	USART_DR - регистр принятого символа (регистр данных)
*	USART_BRR – регистр настройки скорости передачи
*	USART_SR - регистр состояния

*Период вывода информации через BlueTooth модуль должен быть 1 секунда.*


== Приложение должно быть написано на языке С++ с использование компилятора ARM 9.10

Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF. Различные типы памяти могут быть расположены по эти адресам. Обычно микроконтроллер имеет постоянную память, из которой можно только читать (ПЗУ) и оперативную память, из которой можно читать и в которую можно писать (ОЗУ). Также часть адресов этой памяти отведены под регистры управления и регистры периферии. +
Микроконтроллер на ядре Cortex M4 выполнен по Гарвардской архитектуре, память здесь разделена на три типа:

*	*ПЗУ* (FLASH память в которой храниться программа)
*	*ОЗУ* память для хранения временных данных (туда же можно по необходимости переместить программу и выполнить её из ОЗУ), память в которой находятся регистры отвечающие за настройку и работу с периферией и
*	Память для хранения постоянных данных ЕЕPROM.

Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера. 

Семейство ARM9 core состоит из ARM9TDMI, ARM940T, ARM9E-S, ARM966E-S, ARM920T, ARM922T, ARM946E-S, ARM9EJ-S, ARM926EJ-S, ARM968E-S, ARM996HS. +
Версия 9.10 полного набора инструментов разработки IAR Embedded Workbench for Arm добавляет поддержку 64-битных ядер Arm, включая Arm Cortex-A35, Cortex-A53, Cortex-A55, Cortex-A57 и Cortex-A72.

== При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и С++ обертка над ней

FreeRTOS – бесплатная многозадачная операционная система реального времени (ОСРВ) для встраиваемых систем. Портирована на 35 микропроцессорных архитектур. +
Планировщик системы очень маленький и простой, однако можно задать различные приоритеты процессов, вытесняющую и не вытесняющую многозадачность. Ядро системы умещается в 3 -4 файлах. +
FreeRTOS межзадачная коммуникация (упорядоченная передача информации от одной задачи другой задаче)

*	События (Как только событие произошло - задача ожидающая это событие переходи в состояние ГОТОВНОСТИ и планировщик в зависимости от приоритета запускает её на исполнение)
*	Очереди
*	Нотификация задачи

Так как мы будем работать именно с FreeRTOS, то надо подключить бибилиотеку: #include "rtos.hpp"



= Функциональная схема

Приведём функциональную схему устройства, составленной на основе требований технического задания.


.Функциональная схема устройства
image::kr24.png[]

Функциональная схема устройства состоит из следующих блоков:

*	микроконтроллер STM32F411RE;
*	датчик BME280;
*	плата расширения с подключенным к ней Bluetooth-модулем;
*	кнопка выбора единицы измерения температуры;
*	программатор.


= Схема электрическая принципиальная

Приведём электрическую схему, составленной на основе используемых устройств.

.Схема электрическая принципиальная
image::kr25.png[]

= Архитектура проекта 

==	Общая архитектура проекта

Общая архитектура проекта, выполненная в программе StarUML

.Общая архитектура проекта
image::kr26.png[]

.Диаграмма
image::kr28.png[]

== Детальная архитектура

.Общая архитектура проекта
image::kr27.png[]

= Классы

== Класс Measurement

Класс Measurement, описывающий значения измеряемых величин, имеет следующие компоненты:

*	DataSourceFcn - указатель на функцию-поставщик данных;
*	units - массив единиц измерения, используемых для выражения значения этой величины;
*	countOfUnit - длина массива unit;
*	defaultUnit - исходная единица измерения, в которой выражены значения, поставляемые источником данных DataSourceFcn;
*	GetValue() - функция, возвращающая выраженное в defaultUnit значение измеряемой величины;
*	GetValue(unit) - функция, возвращающая значение измеряемой величины, выраженное в выбранной единице измерения unit;
*	quantityName - сторка наименования измеряемой величины;
*	ShowUnitName(unit) - статическая функция, возвращающаяя строку обозначения единицы измерения unit.
*	конструктор, создающий экземпляр класса на основе названия измеряемой величины, массива допустимых единиц измерений, длины этого массива, исходной величины измерения, указателя на функцию-поставщика данных;
*	упрощенный конструктор для величин с одной допустимой единицей измерения, создающий экземпляр класса на основе названия измеряемой величины, единицы измерения, указателя на функцию-поставщика данных.

На рисунке приведены диаграммы класса Measurement, а также экземпляры этих классов temperature, pressure, humidity, dewPoint, указатели на которые объединены в массив measurements.

image::kr29.png[]

=== Код класса Measurement

==== measurement.h

[source, cpp]
#include <string>
#include <cassert>
#pragma once
enum class Unit
{
C,
hPa,
percent
};

class Measurement
{
protected:
double(*DataSourceFcn)();
public:  
const Unit *const units;
const std::size_t countOfUnits;
const Unit defaultUnit;
std::string quantityName;

Measurement(std::string quantityName, Unit* units, std::size_t countOfUnits, Unit defaultUnit, double(*DataSourceFcn)()):
quantityName(quantityName),units(units), countOfUnits(countOfUnits),defaultUnit(defaultUnit), DataSourceFcn(DataSourceFcn)
{
assert(CheckUnit(defaultUnit) &&" defalt unit must match measurement's units");
}
Measurement(std::string quantityName, Unit unit, double(*DataSourceFcn)()):
quantityName(quantityName),defaultUnit(unit),units(&defaultUnit), countOfUnits(1), DataSourceFcn(DataSourceFcn)
{
}

virtual double GetValue()
{
return DataSourceFcn();
}
virtual double GetValue(Unit unit)
{
assert(CheckUnit(unit)&&" defalt unit must match measurement's units");
return DataSourceFcn();
}
bool CheckUnit(Unit unit)
{
bool flag=false;
for(int i=0;i<countOfUnits;i++)
{
if(unit==units[i])
{
flag=true;
}
}
return flag;
}

static string ShowUnitName(Unit unit)
{
string str;
switch(unit)
{  
case Unit::K:
str = "K";
break;
case Unit::F:
str = "F";
break;
case Unit::C:
str = "C";
break;
case Unit::hPa:
str = "hPa";
break;
case Unit::percent:
str = "%";
break;  
default:
assert(false &&" unit must match measurement's units");
break;
}
return str;
}
};


